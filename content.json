{"meta":{"title":"Lcxiao's blog","subtitle":"","description":"","author":"lcxiao","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-05T23:04:57.000Z","updated":"2020-05-06T07:05:12.477Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"hello"},{"title":"categories","date":"2020-05-06T02:30:38.000Z","updated":"2020-05-06T10:30:38.915Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"testing photo","slug":"testing-photo","date":"2020-05-05T23:06:25.000Z","updated":"2020-05-06T07:07:35.501Z","comments":true,"path":"2020/05/05/testing-photo/","link":"","permalink":"http://yoursite.com/2020/05/05/testing-photo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git 和 GitHub 使用入门","slug":"Git-和-GitHub-使用入门","date":"2020-05-05T23:03:09.000Z","updated":"2020-05-06T07:03:25.855Z","comments":true,"path":"2020/05/05/Git-和-GitHub-使用入门/","link":"","permalink":"http://yoursite.com/2020/05/05/Git-%E5%92%8C-GitHub-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"使用常见 Git 命令推送提交到远程仓库使用 git push 将本地分支上的提交推送到远程仓库。git push 命令使用两个参数： 远程命令，如 origin 分支名称，如 master例如：git push &lt;REMOTENAME&gt; &lt;BRANCHNAME&gt;例如，您通常运行 git push origin master 来推送本地更改到在线仓库。 重命名分支要重命名分支，同样使用 git push 命令，但要加上一个或多个参数：新分支的名称。 例如：git push &lt;REMOTENAME&gt; &lt;LOCALBRANCHNAME&gt;:&lt;REMOTEBRANCHNAME&gt;这会将 LOCALBRANCHNAME 推送到 REMOTENAME，但其名称将改为 REMOTEBRANCHNAME。如果仓库的本地副本未同步或“落后于”您推送到的上游分支，您会收到一条消息表示：non-fast-forward updates were rejected。 这意味着您必须检索或“提取”上游更改，然后才可推送本地更改。 推送标记默认情况下，没有其他参数时，git push 会发送所有名称与远程分支相同的匹配分支。要推送单一标记，可以发出与推送分支相同的命令：git push &lt;REMOTENAME&gt; &lt;TAGNAME&gt;要推送所有标记，可以输入命令：git push &lt;REMOTENAME&gt; --tags 删除远程分支或标记删除分支的语法初看有点神秘：git push &lt;REMOTENAME&gt; :&lt;BRANCHNAME&gt; 远程和复刻在克隆您拥有的仓库时，向其提供远程 URL，告知 Git 到何处提取和推送更新。 如果要协作处理原始仓库，可添加新的远程 URL（通常称为 upstream）到本地 Git 克隆：git remote add upstream &lt;THEIR_REMOTE_URL&gt; 从远程仓库获取更改您可以使用常用 Git 命令访问远程仓库。与远程仓库交互时，这些命令非常有用。 clone 和 fetch 用于从仓库的远程 URL 将远程代码下载到您的本地计算机，merge 用于将其他人的工作与您的工作合并在一起，而 pull 是 fetch 和 merge 的组合。 克隆仓库要获取其他用户仓库的完整副本，请使用 git clone，如下所示：git clone https://github.com/USERNAME/REPOSITORY.git将仓库克隆到您的计算机运行 git clone 时，将发生以下操作： 创建名为 repo 的文件夹 将它初始化为 Git 仓库 创建名为 origin 的远程仓库，指向用于克隆的 URL 将所有的仓库文件和提交下载到那里 检出默认分支（通常称为master）对于远程仓库中的每个 foo 分支，在本地仓库中创建相应的远程跟踪分支 refs/remotes/origin/foo。 通常可以将此类远程跟踪分支名称缩写为origin/foo。 从远程仓库获取更改使用 git fetch 可检索其他人完成的新工作。 从仓库获取将会获取所有新的远程跟踪分支和标记，但不会将这些更改合并到您自己的分支中。如果已经有一个本地仓库包含为所需项目设置的远程 URL，您可以在终端使用 git fetch *remotename* 获取所有新信息：git fetch remotename获取远程仓库的更新 合并更改到本地分支合并可将您的本地更改与其他人所做的更改组合起来。 通常将远程跟踪分支（即从远程仓库获取的分支）与您的本地分支进行合并： 12git merge remotename&#x2F;branchname将在线更新与您的本地工作进行合并 从远程仓库拉取更改git pull 是在同一个命令中完成 git fetch 和 git merge 的便捷方式。 12git pull remotename branchname获取在线更新并将其与您的本地工作进行合并 管理远程仓库 添加远程git remote add 命令使用两个参数： 远程命令，如 origin 远程 URL，如 https://github.com/user/repo.git 重命名远程git remote rename 命令使用两个参数： 现有的远程名称，例如 origin 远程的新名称，例如 destination 删除远程git remote rm 命令使用一个参数：远程名称，例如 destination 将子文件夹拆分成新仓库 在 Git 中设置用户名 全局设置： git config --global user.name &quot;Mona Lisa&quot; 为一个仓库设置 Git 用户名 git config user.name &quot;Mona Lisa&quot; 在 Git 中设置您的提交电子邮件地址 git config --global user.email &quot;email@example.com&quot; 在 Git 中缓存 GitHub 密码如果使用 HTTPS 克隆 GitHub 仓库 windows: git config --global credential.helper wincred linux: git config --global credential.helper cache 更改默认的密码缓存时限: git config --global credential.helper &#39;cache --timeout=3600&#39;(以秒为单位) 为什么 Git 总是询问我的密码？如果 Git 在您每次尝试与 GitHub 交互时均提示输入用户名和密码，则您可能为仓库使用的是 HTTPS 克隆 URL。 新增 SSH 密钥到 GitHub 帐户 将 SSH 密钥复制到剪贴板 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; Copy your .ssh/id_rsa.pub 在任何页面的右上角，单击您的个人资料照片，然后单击 Settings（设置）。 在用户设置侧边栏中，单击 SSH and GPG keys（SSH 和 GPG 密钥）。 单击 New SSH key（新 SSH 密钥）或 Add SSH key（添加 SSH 密钥）。 在 “Title”（标题）字段中，为新密钥添加描述性标签。 例如，如果您使用的是个人 Mac，此密钥名称可能是 “Personal MacBook Air”。 将密钥粘贴到 “Key”（密钥）字段。 单击 Add SSH key（添加 SSH 密钥）。 如有提示，请确认您的 GitHub Enterprise 密码。 参考：使用 SSH 连接到 GitHub","categories":[],"tags":[]},{"title":"Text to AscII Art","slug":"Text-to-AscII-Art","date":"2020-05-05T23:02:19.000Z","updated":"2020-05-06T07:02:39.575Z","comments":true,"path":"2020/05/05/Text-to-AscII-Art/","link":"","permalink":"http://yoursite.com/2020/05/05/Text-to-AscII-Art/","excerpt":"","text":"FigletToiletfiglet123Usage: figlet [ -cklnoprstvxDELNRSWX ] [ -d fontdirectory ] [ -f fontfile ] [ -m smushmode ] [ -w outputwidth ] [ -C controlfile ] [ -I infocode ] [ message ] toilet1234567891011121314151617181920-f, --font &lt;name&gt; select the font -d, --directory &lt;dir&gt; specify font directory -s, -S, -k, -W, -o render mode (default, force smushing, kerning, full width, overlap) -w, --width &lt;width&gt; set output width -t, --termwidth adapt to terminal's width -F, --filter &lt;filters&gt; apply one or several filters to the text -F, --filter list list available filters --gay rainbow filter (same as -F gay) --metal metal filter (same as -F metal) -E, --export &lt;format&gt; select export format -E, --export list list available export formats --irc output IRC colour codes (same as -E irc) --html output an HTML document (same as -E html) -h, --help display this help and exit -I, --infocode &lt;code&gt; print FIGlet-compatible infocode -v, --version output version information and exitUsage: toilet [ -hkostvSW ] [ -d fontdirectory ] [ -f fontfile ] [ -F filter ] [ -w outputwidth ] [ -I infocode ] [ -E format ] [ message ] 生成艺术字1234567root@testlab:/usr/share/figlet/fonts# figlet -f Graffiti.flf jack __ __ |__|____ ____ | | __ | \\__ \\ _/ ___\\| |/ / | |/ __ \\\\ \\___| &lt; /\\__| (____ /\\___ &gt;__|_ \\\\______| \\/ \\/ \\/ 1234567root@testlab:~# figlet -f /usr/share/figlet/fonts/Graffiti.flf \"A man from Mars!\" -t _____ _____ _____ ._. / _ \\ _____ _____ ____ _/ ____\\______ ____ _____ / \\ _____ _______ _____| | / /_\\ \\ / \\\\__ \\ / \\ \\ __\\\\_ __ \\/ _ \\ / \\ / \\ / \\\\__ \\\\_ __ \\/ ___/ |/ | \\ | Y Y \\/ __ \\| | \\ | | | | \\( &lt;_&gt; ) Y Y \\ / Y \\/ __ \\| | \\/\\___ \\ \\|\\____|__ / |__|_| (____ /___| / |__| |__| \\____/|__|_| / \\____|__ (____ /__| /____ &gt;__ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/","categories":[],"tags":[]},{"title":"文件系统的挂载和使用","slug":"文件系统的挂载和使用","date":"2020-05-05T22:59:43.000Z","updated":"2020-05-06T07:01:15.272Z","comments":true,"path":"2020/05/05/文件系统的挂载和使用/","link":"","permalink":"http://yoursite.com/2020/05/05/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"文件系统的使用 挂载和卸载mount 和 umount根文件系统以为的文件系统要想能够被访问,必须通过 “关联” 至根文件系统的某个目录上，此关联即为 “挂载” ；此目录即为 “挂载点” ；mount_point：用于作为另一个文件系统的访问入口； 事先存在 应该使用未被或者不会被其他进程使用到的目录； 挂载点下原有的文件会被隐藏；（最好是使用原来是空的目录）；mount命令：1234567891011121314151617181920212223242526mount [-fnrsvw] [-t vfstype] [-o options] device dir -r： readonly，只读挂载（比如光盘）； -w: read and write 读写挂载； -n： 默认情况下，设备挂载或者卸载的操作会同步更新至&#x2F;etc&#x2F;mtab文件中，-n用于禁止此特性； -t vfstype：指明要挂载的设备上的文件系统的类型，多数情况下可自动识别，mount会通过blkid来判断要挂载的设备的文件系统类型； -L LABEL： 挂载是以卷标的方式指明设备； -U UUID DIR: 通过UUID挂载设备； -o: 挂载选项； sync&#x2F;async: 同步&#x2F;异步操作；（异步是先写入内存，随后写入磁盘，性能好，但安全行肯定没有同步安全） atime&#x2F;noatime: 每个文件或目录被访问时是否立即更新其访问时间戳； diratime&#x2F;nodiratime: 每个目录被访问时是否立即更新其访问时间戳； remount: 重新挂载 acl: 支持使用acl功能； mount -o acl DEVICE DIR tune2fs -o acl device ro： 只读 rw： 读写 dev&#x2F;nodev： 此设备上是否允许创建设备文件； exec&#x2F;noexec： 是否允许运行此设备上的文件； auto&#x2F;noauto： 是否允许自动运行； user&#x2F;nouser： 是否允许普通用户挂载此文件系统； suid&#x2F;nosuid： 是否允许程序文件上的suid和sgid特殊权限生效； defaults： 使用默认选项：rw，suid，dev，exec，auto，nouser和async。 请注意，所有默认安装选项的实际设置取决于内核和文件系统类型。技巧：可以实现将目录绑定至另一个目录上，作为其临时访问入口mount --bind 源目录 目标目录 mount -r /dev/cdrom mount_point光盘设备一般为： /dev/cdrom /dev/dvd /dev/sr0挂载U盘： 事先识别U盘的设备文件：挂载本地回环设备； mount -o loop /PATH/TO?SOME_LOOP_FILE MOUNT_POINT 例如ISO镜像文件查看当前已挂载的设备: mount cat /proc/mounts cat /etc/mtab 查看挂载设备被哪些进程所占用fuser -v MOUNT_POINT lsof MOUNT_POINT终止所有正在访问某挂载点的进程：fuser -km MOUNT_POINTumount命令：umount device | dir注意：正在被进程访问到的挂载点无法被卸载： 交换分区mkswap 启用：swapon -a 所有swap文件；(定义在fstab文件中的swap设备)； 禁用：swapoff swapoff DEVICE设定除根文件系统以外的其他文件系统能够开机时自动挂载： /etc/fstab文件 要挂载的设备 挂载点 文件系统类型 挂载选项 转储频率（备份） 自检次序 设备文件 swap为swap defaults 0从不 0不自检 LABEL acl 1每天 1，首先自检，通常根是1 UUID noatime 2隔天 2 次级自检 伪文件系统proc，sysfs，tmpfs noexec mount -a： 可自动挂载定义在此文件中的所有支持的自动挂载的设备 两个命令：du：估计文件空间使用率; -h: 以人类可读的格式打印尺寸（例如1K 234M 2G） -s: 对于目录，不包括子目录的大小; df：报告文件系统磁盘空间使用情况; -l: 将列表限制为本地文件系统; -h: 以1024的幂为单位的打印尺寸（例如1023M） -i: 列出索引节点信息而不是块使用情况; -a: 包括伪，重复，不可访问的文件系统;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-05T13:44:34.961Z","updated":"2020-05-05T13:44:34.961Z","comments":true,"path":"2020/05/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2020-05-05T08:44:14.000Z","updated":"2020-05-05T16:45:17.520Z","comments":true,"path":"2020/05/05/test/","link":"","permalink":"http://yoursite.com/2020/05/05/test/","excerpt":"","text":"This is a test file.","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux centos ubuntu js yml html python","slug":"linux-centos-ubuntu-js-yml-html-python","permalink":"http://yoursite.com/tags/linux-centos-ubuntu-js-yml-html-python/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux centos ubuntu js yml html python","slug":"linux-centos-ubuntu-js-yml-html-python","permalink":"http://yoursite.com/tags/linux-centos-ubuntu-js-yml-html-python/"}]}