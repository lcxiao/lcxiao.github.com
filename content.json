{"meta":{"title":"Lcxiao's blog","subtitle":"","description":"","author":"lcxiao","url":"http://lcxiao.ga","root":"/"},"pages":[{"title":"tags","date":"2020-05-06T04:23:56.000Z","updated":"2020-05-06T13:28:24.655Z","comments":true,"path":"tags/index.html","permalink":"http://lcxiao.ga/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-06T05:25:06.000Z","updated":"2020-05-06T13:25:25.867Z","comments":true,"path":"about/index.html","permalink":"http://lcxiao.ga/about/index.html","excerpt":"","text":"a man from Mars."},{"title":"categories","date":"2020-05-06T05:25:48.000Z","updated":"2020-05-06T13:27:54.644Z","comments":true,"path":"categories/index.html","permalink":"http://lcxiao.ga/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux平台RAID","slug":"Linux平台RAID","date":"2020-05-06T05:23:39.000Z","updated":"2020-05-06T13:23:52.879Z","comments":true,"path":"2020/05/06/Linux平台RAID/","link":"","permalink":"http://lcxiao.ga/2020/05/06/Linux%E5%B9%B3%E5%8F%B0RAID/","excerpt":"","text":"RAIDRedundant Array of Independent Disks 独立硬盘冗余阵列,旧称廉价磁盘冗余阵列.简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。 在运作中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID 0、RAID 1、RAID 5、RAID 6、RAID 7、RAID 01、RAID 10、RAID 50、RAID 60。每种等级都有其理论上的优缺点，不同的等级在两个目标间获取平衡，分别是增加数据可靠性以及增加存储器（群）读写性能。 简单来说，RAID把多个硬盘组合成为一个逻辑硬盘，因此，操作系统只会把它当作一个实体硬盘。RAID常被用在服务器电脑上，并且常使用完全相同的硬盘作为组合。由于硬盘价格的不断下降与RAID功能更加有效地与主板集成，它也成为普通用户的一个选择，特别是需要大容量存储空间的工作，如：视频与音频制作。 RAID等级 最少硬盘 最大容错 可用容量 读取性能 写入性能 安全性 目的 应用产业 0 2 0 n n n 一个硬盘异常，全部硬盘都会异常 追求最大容量、速度 影片剪接缓存用途 1 2 n-1 1 n 1 高，一个正常即可 追求最大安全性 个人、企业备份 5 3 1 n-1 n-1 n-1 高 追求最大容量、最小预算 个人、企业备份 6 4 2 n-2 n-2 n-2 安全性较RAID 5高 同RAID 5，但较安全 个人、企业备份 10 4 高 综合RAID 0/1优点，理论速度较快 大型数据库、服务器 50 6 高 提升数据安全 60 8 高 提升数据安全 单一硬盘 (参考) 0 1 1 1 无 jBOD 1 0 n 1 1 无（同RAID 0） 增加容量 个人（暂时）存储备份 标准RAID参数说明1. n代表硬盘总数 2. JBOD（Just a Bunch Of Disks）指将数个物理硬盘，在操作系统中合并成一个逻辑硬盘，以直接增加容量 3. 依不同 RAID 厂商实现算法对于性能表现会有不同，性能公式仅供参考 4. RAID 10、50、60 依实现 Parity 不同公式也不同RAID 0它将两个以上的磁盘并联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID 0的速度是最快的。但是RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失。 读写性能提升：可用空间：N*min(S1,S2…)无容错能力最小磁盘数:2 RAID 1两组以上的N个磁盘相互作镜像，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，与RAID 0相同。另外写入速度有微小的降低。只要一个磁盘正常即可维持运作，可靠性最高。其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的一个级别。 读性能提升、写性能略微下降：可用空间：1*min(S1,S2…)有冗余能力最少磁盘数：2 RAID 2 (不常见)这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分割为独立的比特，并将数据分别写入硬盘中。因为在数据中加入错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些。 RAID 2最少要三台磁盘驱动器方能运作。 RAID 3 (不常见)采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。 RAID 4它与RAID 3不同的是它在分割时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）1101,0110,1011 RAID 5RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分割）技术。 RAID 5至少需要三个硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。RAID 5可以理解为是RAID 0和RAID 1的折衷方案。RAID 5可以为系统提供数据安全保障，但保障程度要比镜像低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用“回写缓存”可以让性能改善不少。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较便宜。 读写性能提升可用空间：(N-1)*min(S1,S2…)有容错能力，1块硬盘最少磁盘数3 RAID 6读写性能提升可用空间：(N-2)*min(S1,S2…)有容错能力，2块硬盘最少磁盘数4 混合RAIDJBODjust a bunch of disks功能：将多块硬盘的空间合并一个大的连续空间使用；可用功能：sum(S1,S2…) RAID 10读写性能提升可用空间：N*min(S1,S2…)/2有容错能力：每组镜像最多只能坏一块；最少磁盘数4 RAID 01 RAID 50 RAID 60 应用RAID2、3、4较少实际应用，因为RAID0、RAID1、RAID5、RAID6和混合RAID已经涵盖所需的功能，因此RAID2、3、4大多只在研究领域有实现，而实际应用上则以RAID0、RAID1、RAID5、RAID6和混合RAID为主。 RAID4有应用在某些商用机器上，像是NetApp公司设计的NAS系统就是使用RAID4的设计概念。 种类根据实现模式，分为软件和硬件两种：CentOS6上面 软件方式实现：结合内核中的md(multi devices)mdadm 模式化的工具 命令的语法格式： mdadm [mode] &lt;raiddevice&gt; [options] &lt;componet-devices&gt;支持的RAID级别：LINEAR,RAID0,RAID1,RAID4,RAID5,RAID6,RAID10; 模式： 123创建： -C装配： -A监控： -F 12345678910管理： -f， -r， -a &lt;raiddevice&gt;: &#x2F;dev&#x2F;md# &lt;component-devices&gt;: 任意块设备-C: 创建模式： -n #: 使用#个块设备来创建此RAID； -l #: 指明要创建的RAID的级别； -a: &#123;yes| no&#125; 自动创建目标RAID设备的设备文件； -c: CHUNK_SIZE 指定块大小 -x: 指明空闲盘的个数 例如：创建一个10G可用空间的RAID5； 创建mdadm -C /dev/md0 -a yes -n 3 -x 1 -l 5 /devsda{7,8,9,10}格式化mkfs -v -t ext4 /dev/md0挂载使用：mount /dev/md0 MOUNT_POINT 显示设备信息:-D：显示RAID的详细信息；mdadm -D /dev/md# 管理模式：-f 标记指定磁盘为损坏；mdadm /dev/md0 -fdev/sda# -a 添加磁盘mdadm /dev/md0 -adev/sda# -r 移除磁盘mdadm /dev/md0 -rdev/sda# 观察md的状态；cat /proc/mdstat 停止md设备mdadm -S /dev/md# 先卸载设备umount /dev/md0mdadm -S /dev/md0 watch 命令：-n # 刷新间隔，单位是秒watch -n# &quot;command&quot; 练习1：创建一个可用空间为10G的RAID1设备，要求其chunk大小为128k，文件系统为ext4，有一个空闲盘，开机可自动挂载至/backup目录； 123mdadm -C /dev/md0 -c 128K -x 1 -n 2 -l 1 -a yes /deb/sda&#123;5,6,7&#125;mkfs -v -t ext4echo \"`blkid /dev/md0 | awk '&#123;print $3&#125;'` /backup ext4 defaults 0 0\" &gt;&gt; /etc/fstab 练习2：创建一个可用空间为10G的RAID10设备，要求chunk大小为256k，文件系统为ext4，开机可自动挂载至/mydata目录； 123mdadm -C /dev/md0 -c 256K -n 4 -l 10 -a yes /dev/sdb&#123;7,8,9,10&#125;mkfs -v -t ext4echo \"`blkid /dev/md0 | awk '&#123;print $3&#125;'` /mydata ext4 defaults 0 0\" &gt;&gt; /etc/fstab 磁盘阵列相关客户类型 一般消费者备份数据之用、企业创建ERP系统或NAS系统时的重要数据备份。 影音多媒体数字内容创作公司、个人影音剪辑数字内容工作室、摄影工作室、摄影公司。 电视台、广播电台及互联网内容提供商等传统媒体及新媒体。 数字监控系统（DVR）、网络监控系统（NVR）等等需要大量存储影片的监控系统业者，军方、赌场因为需要大量监控系统也是常见使用磁盘阵列的客户。 证券、银行等金融行业保管重要客户数据。 参考Arch Wiki 常用级别：RAID-0、RAID-1、RAID-5、RAID-10、RAID-50、JBOD ????RAID各级别特性","categories":[],"tags":[]},{"title":"progit","slug":"progit","date":"2020-05-06T05:23:11.000Z","updated":"2020-05-06T13:23:24.028Z","comments":true,"path":"2020/05/06/progit/","link":"","permalink":"http://lcxiao.ga/2020/05/06/progit/","excerpt":"","text":"版本控制–&gt; 版本控制系统–&gt;本地版本控制系统–&gt;集中化的版本控制系统–&gt;分布式版本控制系统 Git 是什么？分布式版本控制系统客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像 下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像 出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份. 直接记录快照，而非差异比较 快照流 近乎所有操作都是本地执行 Git 保证完整性 Git 用以计算校验和的机制叫做 SHA-1 散列 Git 数据库中保存的信息都是以文件内 容的哈希值来索引，而不是文件名. Git 一般只添加数据 三种状态 已提交（committed） 已提交表示数据已经安全地保存在本地数据库中. 已修改（modified） 修改了文件，但还没保存到数据库中。 已暂存（staged） 示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上 供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索 引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆 仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。 如果文件已修改并放入暂存区，就属于 已暂存 状 态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态. 安装从源代码安装 :从源码安装 Git，需要安装 Git 依赖的库：autotools、curl、zlib、openssl、expat 和 libiconv。 123$ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \\ openssl-devel perl-devel zlib-devel $ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \\ gettext libz-dev libssl-dev 为了添加文档的多种格式（doc、html、info），需要以下附加的依赖： 12$ sudo dnf install asciidoc xmlto docbook2X $ sudo apt-get install asciidoc xmlto docbook2x 使用 RHEL 和 RHEL 衍生版，如 CentOS 和 Scientific Linux 的用户需要 开启 EPEL 库 以便下 载 docbook2X 包。 使用基于 Debian 的发行版（Debian/Ubuntu/Ubuntu-derivatives），你也需要 install-info 包：$ sudo apt-get install install-info 如果你使用基于 RPM 的发行版（Fedora/RHEL/RHEL衍生版），你还需要 getopt 包 （它已经在基于 Debian 的发行版中预装了）：sudo dnf install getopt 此外，如果你使用 Fedora/RHEL/RHEL衍生版，那么你需要执行以下命令：$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi 当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站 获取，网址为 https://www.kernel.org/pub/software/scm/git， 或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签 名，如果你想验证下载正确性的话会用到。 123456tar -zxf git-2.8.0.tar.gzcd git-2.8.0make configure./configure --prefix=/usr make all doc infomake install install-doc install-html install-info 完成后，你可以使用 Git 来获取 Git 的更新：git clone git://git.kernel.org/pub/scm/git/git.git Git 基础获取 Git 仓库通常有两种获取 Git 项目仓库的方式： 将尚未进行版本控制的本地目录转换为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123$ git add *.c $ git add LICENSE $ git commit -m 'initial project version' 克隆现有的仓库 git clone &lt;url&gt; 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放 入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 检查当前文件状态 git status 跟踪新文件 git add 忽略文件 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子： 123$ cat .gitignore *.[oa] *~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二 行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存 副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的 新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件 我们再看一个 .gitignore 文件的例子： 123456789101112# 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO /TODO # 忽略任何目录下名为 build 的文件夹 build/ # 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 doc/**/*.pdf 查看已暂存和未暂存的修改 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff; 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令。 这条命令将比对已暂存 文件与最后一次提交的文件差异; 然后用 git diff --cached 查看已经暂存起来的变化（ –staged 和 –cached 是同义词）; 提交更新 git commit 你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时 纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较 跳过使用暂存区域 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂 存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤： 123$ git commit -a -m 'added new benchmarks'[master 83e38c7] added new benchmarks1 file changed, 5 insertions(+), 0 deletions(-) 移除文件 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。 查看提交历史 git log","categories":[],"tags":[]},{"title":"Bash脚本编程","slug":"Bash脚本编程","date":"2020-05-06T05:22:33.000Z","updated":"2020-05-06T13:30:13.312Z","comments":true,"path":"2020/05/06/Bash脚本编程/","link":"","permalink":"http://lcxiao.ga/2020/05/06/Bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/","excerpt":"","text":"脚本文件格式第一行写上#!/bin/bash注释信息 #代码注释：适当的缩进和空白行； 语言：编程语法格式，库，算法和数据结构；编程思想：问题空间 –&gt; 解空间 Bash是典型的弱类型的编程语言数据类型：字符型、整数值弱类型：字符型 变量：局部变量本地变量环境变量位置参数变量特殊变量 算数运算12345+, -, *, /, %, **let VAR=expressionVAR=$[expression]VAR=$((expression))VAR=$(expr argu1 argu2 argu3) 增强型赋值变量做某种算数运算后回存到此变量中； 12let i=$i+#let i+=# +=, -=, *=, /=, %= 条件测试：判断某需求是否满足；需要测试机制来实现； 执行命令，根据命令的返回值来判断；0：成功1-255： 失败 测试表达式；test expression[ expression ][[ expression ]]注意： expression两端必须有空白字符，否则为语法错误； Bash的测试类型： 数值测试 字符串测试 文字测试 数值测试： 数值比较；-eq： 是否等于；[ A -eq B ]; -ne： 是否不等于； -gt： 是否大于； -ge： 是否大于等于； -lt： 是否小于； -le： 是否小于等于；代码中的 [] 执行基本的算数运算，如： 1234567#!/bin/basha=5b=6result=$[a+b] # 注意等号两边不能有空格echo \"result 为： $result\" 字符串测试:1234567==： 是否等于；&gt;： 是否大于；&lt;： 是否小于；!=：是否不等于；=~： 左侧字符串是否能被右侧的PATTERN匹配；-z \"STRING\"： 判断指定的字符串是否为空；空为真，非空为假。-n \"STRING\"： 判断指定的字符串是否非空，非空为真，空为假； 注意： 字符串要加引用； 要使用[[ ]]; 文件测试： 存在测试： 12-a FILE-e FILE: 如果文件存在则为真 存在及类型测试： 123456789101112131415-b 如果文件存在且为块特殊文件则为真-c 如果文件存在且为字符型特殊文件则为真-d 如果文件存在且为目录则为真-f 如果文件存在且为普通文件则为真-h 链接文件-p 管道文件-S 套接字文件3. 文件权限测试：-r 存在且可读-w 存在且可写-x 存在且可执行4. 特殊权限测试：-u 存在且拥有suid-g 存在且拥有sgid-k 存在且拥有sticky 文件内容测试： 1-s 是否有内容 时间戳： 1-N FILE ：文件自上一次读操作后是否被修改； 从属关系测试： 12-O FILE：当前用户是否为文件的属主；-G FILE：当前用户是否为文件的属组； 双目测试： 123FILE1 -ef FILE2；FILE1与FILE2是否指向同一个文件系统的相同inode的硬链接；FILE1 -nt FILE2：FILE1是否新于FILE2；FILE1 -ot FILE2：FILE1是否旧于FILE2； 组合测试条件：逻辑运算： 123456789101. COMMAND1 &amp;&amp; COMMAND2 COMMAND1 || COMMAND2 !COMMAND [ -O FILE ] &amp;&amp; [ -r FILE ]2. EXPRESSION1 -a EXPRESSION2 EXPRESSION1 -O EXPRESSION2 !EXPRESSION [ -O FILE -a -x FILE ] 练习：将当前主机名称保存至hostname变量中：主机名如果为空，或者为localhost.localdomain,则将其设置为www.magedu.com; 123#!/bin/bashhostname=$(hostname)[ -z \"$hostname\" -o \"$hostname\"==\"localhost.localdomain\" -o \"$hostname\"==\"localhost\" ] &amp;&amp; hostname www.magedu.com 脚本的状态返回值：默认是脚本执行的最后一条命令的返回值；自定义状态退出状态码:exit [n]：n为自己指定的状态码；注意：SHELL进程遇到exit时，即会终止，因此整个脚本执行即为结束。 向脚本传递参数位置参数变量myscript.sh引用方式：$1,$2,$3…$10,$11…轮替：shift [n]: 位置参数轮替： 1234#!/bin/bashfile1_lines=$(grep \"^$\" $1 | wc -l)file2_lines=$(grep \"^$\" $2 | wc -l)echo \"Total blank lines: $[$file1_lines+$file2_lines]\" 特殊变量：1234$0:脚本文件路径本身;$#:脚本参数的个数；$*:所有参数 （分割为多个字符串）$@:所有参数 （合并为一个字符串） [ $# -lt 2 ] &amp;&amp; echo &quot;At least two files&quot; &amp;&amp; exit 1如果参数个数小于2个，提示至少需要2个参数，并退出，状态码1 过程式编程语言的代码执行顺序：顺序执行： 逐条执行；选择执行： 代码有一个分支： 条件满足时才会执行； 两个或以上的分支：只会执行其中一个满足条件的分支；循环执行： 某代码片段（循环体）要执行0、1或者多个来回；选择执行：单分支的if语句：if 测试条件then 代码分支fi 双分支的if语句if 测试条件；then 条件为真时执行的分支else 条件为假时执行的分支fi 示例： 通过参数传递一个用户名给脚本，此用户不存在时，则添加之； 1234567891011#!/bin/bash#[ $# -lt 1 ] &amp;&amp; echo \"At least one username.\" &amp;&amp; exit 1if ! grep \"^$1\\&gt;\" /etc/passwd &amp;&gt; /dev/null; then useradd $1 echo $1 | passwd --stdin $1 &amp;&gt; /dev/null echo \"Add user $1 finished.\"else echo \"user $1 exist.\"fi 练习1： 通过命令行参数给定两个数字，输出其中较大的数值；练习2： 通过命令行参数指定一个用户名，判断其ID号是偶数还是奇数；练习3： 通过命令行参数给定两个文本文件名，如果某文件不存在，则结束脚本执行； 都存在时返回每个文件的行数，并说明其中行数较多的文件；","categories":[{"name":"Linux","slug":"Linux","permalink":"http://lcxiao.ga/categories/Linux/"}],"tags":[{"name":"Bash -","slug":"Bash","permalink":"http://lcxiao.ga/tags/Bash/"}]},{"title":"磁盘和文件系统","slug":"磁盘和文件系统","date":"2020-05-06T05:22:01.000Z","updated":"2020-05-06T13:22:19.235Z","comments":true,"path":"2020/05/06/磁盘和文件系统/","link":"","permalink":"http://lcxiao.ga/2020/05/06/%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"机械硬盘物理参数数据接口硬盘按数据接口不同，大致分为ATA（又称IDE）和SATA以及SCSI和SAS。接口速度不是实际硬盘数据传输的速度，当前普通硬盘的实际数据传输速度一般不会超过300MB/s。 ATA全称Advanced Technology Attachment，是用传统的40-pin并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被SATA所取代。 SATA全称Serial ATA，也就是使用串口的ATA接口，特点是抗干扰性强，对数据线的要求比ATA低很多，且支持热插拔等功能。SATA-II的接口速度为300MiB/s，而新的SATA-III标准可达到600MiB/s的传输速度。SATA的数据线也比ATA的细得多，有利于机箱内的空气流通，整理线材也比较方便。 SCSI全称Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的SCSI-II，到当前的Ultra320 SCSI以及Fiber-Channel（光纤通道），接口型式也多种多样。SCSI硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速15000rpm的高转速，且资料传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。 SAS全称Serial Attached SCSI，是新一代的SCSI技术，可兼容SATA硬盘，都是采取序列式技术以获得更高的传输速度，可达到12Gb/s。此外也透过缩小连接线改善系统内部空间等。 此外，由于SAS硬盘可以与SATA硬盘共享同样的背板，因此在同一个SAS存储系统中，可以用SATA硬盘来取代部分昂贵的SAS硬盘，节省整体的存储成本。但SATA存储系统并不能连接SAS硬盘。 FC全称Fibre Channel（光纤通道接口），拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（4Gb/s或10Gb/s）、远程连接等特点；内部传输速率也比普通硬盘更高。但其价格高昂，因此FC接口通常只用于高端服务器领域。 电源接口3.5寸台式机硬盘：ATA接口的硬盘一般使用D形4针电源接口（俗称“大4pin”），由Molex公司设计并持有专利；SATA硬盘则使用SATA电源线。2.5寸的笔记本电脑硬盘，可直接由数据口供电，不需要额外的电源接口。在插上外接的便携式硬盘盒之后，由计算机外部的USB接口提供电力来源，而单个USB接口供电约为4~5V 500mA，若移动硬盘盒用电需求较高，有时需要接上两个USB接口才能使用，否则，需要外接电源供电。但如今多数新型硬盘盒（使用2.5寸或以下硬盘）已可方便地使用单个USB口供电。 避免故障硬盘碟片转速极快，与碟片的距离极小；因此硬盘内部是无尘状态，硬盘有过滤器过滤进入硬盘的空气。为了避免磁头碰撞碟片，厂商设计出各种保护方法；当前硬盘对于地震有很好的防护力（1990年代的一些硬盘，若在使用中碰到略大的地震，就很可能损坏），防摔能力也大幅进步，电源关闭及遇到较大震动时磁头会立刻移到安全区（近期的硬盘也开始防范突然断电的情况）；而许多笔记本电脑厂商也开发出各种笔记本电脑结构来加强硬盘的防摔性。但硬盘在通电时耐摔度会降低（旋转逆动性）、也只能温和的移动，许多人也已经养成在关闭硬盘后30秒至一分钟内、不会移动硬盘（及笔记本电脑）的习惯。2010年后氦气封装技术量产，以往的硬盘填充介质为空气，不过容易受到空气影响，因此碟片之间距离要够才行，而氦气的密度比起空气小上许多，且氦气特色就是稳定，使用他来当介质，阻力和震动相对小，因此碟片之间的距离就能缩小，所以同样的空间下能够装下更多的碟片，采用氦气封装的好处除了容量变大外[4]，温度和耗电能够再降低，因此耐用度和稳定性能够再提升。 逻辑结构操作系统对硬盘进行读写时需要用到文件系统把硬盘的扇区组合成簇，并创建文件和树形目录制度，使操作系统对其访问和查找变得容易，这是因为操作系统直接对数目众多的扇区进行寻址会十分麻烦。 尺寸硬盘驱动器的尺寸和用途可分为： 0.85英寸，多用于手机等便携设备中，已无厂商生产。 1英寸（微型硬盘，MicroDrive），多用于数字相机（CF type II接口），已无厂商生产。 1.8英寸，多用于笔记本电脑及外置硬盘盒中，已无厂商生产。 2.5英寸，多用于笔记本电脑及外置硬盘盒中。采用2.5”硬盘的外置硬盘盒一般不需外接电源。 3.5英寸，多用于台式机中。采用3.5”硬盘的外置硬盘盒一般需要外接电源，因为耗电量超过USB的供电上限，一直到USB 3.0问世后获得解决。 5.25英寸，多为早期台式机使用，已无厂商生产。 10.5英寸。 14英寸，NEC DKU800。容量当前硬盘的容量有36GB、40GB、45GB、60GB、75GB、80GB、120GB、150GB、160GB、200GB、250GB、300GB、320GB、400GB、500GB、640GB、750GB、1TB、1.5TB、2TB、2.5TB、3TB、4TB、5TB、6TB、8TB、10TB、12TB、14TB等多种规格转速硬盘每分钟旋转的圈数，单位是rpm（每分钟的转动数），有4200rpm、5400rpm、5900rpm、7200rpm、10000rpm、15000rpm、18000rpm等几种规格。一般来讲转速愈高通常数据传输速率愈好，但同时噪音、耗电量和发热量也较高。缓存主要有2MB、8MB、16MB、32MB、64MB、128MB、256MB等规格。平均寻道时间单位是ms（毫秒），有5.2ms、8.5ms、8.9ms、12ms等规格。内部传输速度包括磁头把数据从盘片读入缓存的速度，以及磁头把数据从缓存写入盘片的速度。可用来评价硬盘的读写速度和整体性能. 一般固态硬盘的输入电压在5V左右，偏差5%以内。一般功耗较低，2.5W左右，电流500mA，这样即使usb2.0接口也能采用。 传输速率 SATA: 6gbps SAS: 6gbps USB: 480MB/s SSD固态硬盘采用SATA、PCI Express、M.2、mSATA、SAS、U.2、ZIF、IDE、CF、CFast等接口。由于价格及存储空间与机械硬盘有巨大差距，固态硬盘无法取代机械式硬盘。损坏时不可挽救 Linux的哲学思想： 一切皆文件设备类型：块文件（block）随机访问，数据交换单位是‘块’字符（character）线性访问，数据交换单位是‘字符’设备文件 FHS/dev 关联至设备的驱动程序：设备的访问入口 设备号：major：主设备号，区分设备类型；用于表明设备所需的驱动程序minor：此设备号，区分同种类型下的不同设备，特定设备的访问入口 mknod 命令:创建块类型和字符类型的特殊文件。 12mknod [option]... NAME TYPE [major minor] -m MODE:创建后的设备文件的访问权限。 磁盘:分区机制IDE /dev/hd[a-z]SCSI,SATA,USB,SAS:/dev/sd[a-z]引用设备的方式：设备文件名、卷标、UUID MBR和GPTMBR446bytes: bootloader64bytes: 分区表，每16bytes标识一个分区，一共只能有4个分区 4主分区 3主1扩展主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是电脑引导后访问硬盘时所必须要读取的首个扇区，主引导扇区记录着硬盘本身的相关消息以及硬盘各个分割的大小及位置消息，是数据消息的重要入口。如果它受到破坏，硬盘上的基本数据结构消息将会丢失，需要用繁琐的方式试探性的重建数据结构消息后才可能重新访问原先的数据，对于那些扇区为512位组的磁盘，MBR分割表不支持容量大于2.2TB（2.2×1012字节）的分割。 GPT全局唯一标识分区表（GUID Partition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准（被Intel用于替代个人计算机的BIOS）的一部分。GPT分配64bits给逻辑块地址，因而使得最大分区大小在264-1个扇区成为了可能。对于每个扇区大小为512字节的磁盘，那意味着可以有9.4ZB（9.4 x 1021字节）或8 ZiB-512字节（9,444,732,965,739,290,426,880字节或 18,446,744,073,709,551,615（264-1）个扇区x 512（29）字节每扇区）。 fdisk123456789fdisk -l fdisk device n: new d: del t: modify w: save q: without save quit m: help p: print 显示内核已识别的所有分区: 1234567891011root@testlab:~# cat &#x2F;proc&#x2F;partitions major minor #blocks name 8 16 20971520 sdb 8 17 20970479 sdb1 8 0 20971520 sda 8 1 748544 sda1 8 2 1 sda2 8 5 20219904 sda5 252 0 19214336 dm-0 252 1 999424 dm-1 使内核重读分区centOS5: partprobe [device]centOS6,7: partx -a [device] (有时需要两次)parted: GNU Parted 是创建和处理分区表的程序。GParted 是 GUI 前端。sfdisk: Partition table manipulator for Linuxcfdisk: Curses based disk partition table manipulator for Linux 创建文件系统磁盘格式化格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。格式化通常分为低级格式化和高级格式化。如果没有特别指明，对硬盘的格式化通常是指高级格式化，而对软盘的格式化则通常同时包括这两者。 低级格式化被用于指代对磁盘进行划分柱面、磁道、扇区的操作。高级格式化又称逻辑格式化，它是指根据用户选定的文件系统（如FAT12、FAT16、FAT32、exFAT、NTFS、EXT2、EXT3等），在磁盘的特定区域写入特定数据，以达到初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作。高级格式化包括对主引导记录中分区表相应区域的重写、根据用户选定的文件系统，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间，以便用户使用该分区管理文件。 inodeinode: (index node)是指在许多“类Unix文件系统”中的一种数据结构，用于描述 文件系统对象（包括文件、目录、设备文件、socket、管道, 等等）。每个inode保存了 文件系统对象数据 的属性和磁盘块位置。文件系统对象属性 包含了各种元数据（如：最后修改时间） ，也包含用户组（owner ）和权限数据。 文件系统创建（格式化）时，就把存储区域分为两大连续的存储区域。一个用来保存文件系统对象的元信息数据，这是由inode组成的表，每个inode默认是256字节或者128字节。另一个用来保存“文件系统对象”的内容数据，划分为512字节的扇区，以及由8个扇区组成的4K字节的块。块是读写时的基本单位。一个文件系统的inode的总数是固定的。这限制了该文件系统所能存储的文件系统对象的总数目。典型的实现下，所有inode占用了文件系统1%左右的存储容量。 POSIX inode123456789101112POSIX标准强制规范了文件系统的行为。每个“文件系统对象”必须具有：以字节为单位表示的文件大小。设备ID，标识容纳该文件的设备。文件所有者的User ID。文件的Group ID文件的模式（mode），确定了文件的类型，以及它的所有者、它的group、其它用户访问此文件的权限。额外的系统与用户标志（flag），用来保护该文件。3个时间戳，记录了inode自身被修改（ctime, inode change time）、文件内容被修改（mtime, modification time）、最后一次访问（atime, access time）的时间。1个链接数，表示有多少个硬链接指向此inode。到文件系统存储位置的指针。通常是1K字节或者2K字节的存储容量为基本单位。使用stat系统调用可以查询一个文件的inode号码及一些元信息。 Linux 的硬链接与软链接链接简单说实际上是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。你可以将链接简单地理解为 Windows 中常见的快捷方式（或是 OS X 中的替身），Linux 中常用它来解决一些库版本的问题，通常也会将一些目录层次较深的文件链接到一个更易访问的目录中。在这些用途上，我们通常会使用到软链接（也称符号链接）。 从使用的角度讲，两者没有任何区别，都与正常的文件访问方式一样，支持读写，如果是可执行文件的话也可以直接执行。 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块有相同的inode,每增加一个硬链接，会使文件inode引用计数增加ln src link 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。inode 不同，删除符号连接不影响源文件，但删除原文件会使符号链接无效，建立符号链接不影响文件inode引用计数设备文件： 存储数据指针的空间当中存储的是设备号（major，minor）；bitmap index： 位图索引。ln -s src linkVFS：Virtual File System linux文件系统：ext2,ext3,ext4,xfs,relserfs,brfs 光盘：iso9660 网络文件系统：nfs,cifs 集群：gfs2,ocfs2 内核级分布：ceph windows：vfat,ntfs 伪文件：proc,sysfs,tmpfs,hugepagefs Unix：UFS,FFS,JFS 交换：SWAP 用户空间的分布式：mogliefs,moosefs,glusterfs journal 日志文件系统日志系统：元数据metadata和数据data日志文件系统（英语：Journaling file system）是一种文件系统在发生变化时，先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统的文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。 对文件系统进行修改时，需要进行很多操作。这些操作可能中途被打断，也就是说，这些操作不是“不可中断”(atomic)的。如果操作被打断，就可能造成文件系统出现不一致的状态。 例如：删除文件时，先要从目录树中移除文件的标示，然后收回文件占用的空间。如果在这两步之间操作被打断，文件占用的空间就无法收回。文件系统认为它是被占用的，但实际上目录树中已经找不到使用它的文件了。 在非日志文件系统中，要检查并修复类似的错误就必须对整个文件系统的数据结构进行检查。一般在挂载文件系统前，操作系统会检查它上次是否被成功卸载，如果没有，就会对其进行检查。如果文件系统很大或者I/O带宽有限，这个操作可能会花费很长时间。为了避免这样的问题，日志文件系统分配了一个称为日志（journal）的区域来提前记录要对文件系统做的更改。在崩溃后，只要读取日志重新执行未完成的操作，文件系统就可以恢复一致。这种恢复是原子的，因为只存在几种情况： 不需要重新执行：这个事务被标记为已经完成 成功重新执行：根据日志，这个事务被重新执行 无法重新执行：这个事务会被撤销，就如同这个事务从来没有发生过 日志本身不完整：事务还没有被完全写入日志，它会被简单忽略日志的三个级别 回写在回写模式中，只有元数据被记录到日志中，数据会被直接写入主文件系统。这种模式能提供较好的性能，不过有较大的风险。例如：在增大文件时，数据还未写入就发生崩溃，那么文件系统恢复后，文件后面就可能出现垃圾数据。 顺序在顺序模式中，只有元数据被记录到日志中，但在日志被标记为提交前，数据会被写入文件系统。在这种模式下，如果在增大文件时，数据还未写入就发生崩溃，那么在恢复时这个事务会被简单的撤销，文件保持原来的状态。 数据 123- 日志完整：这时事务会被重新执行，修改会被提交到主文件系统- 日志不完整：这时主文件系统还未被修改，只需要简单放弃这个事务 常见的日志文件系统 JFS：IBM的 Journaled File System, 最早的日志文件系统[1]。 Ext4/Ext3文件系统：由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。 XFS文件系统：广泛用于Linux系统，取代了Ext4。 ReiserFS：用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。 Btrfs：用B树作为数据结构，被认为是下一代Linux文件系统[2]。 NTFS：微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。 HFS+：苹果公司发展的OS X操作系统下主要使用的文件系统。 文件系统管理工具 创建1234567891011mkfs -v -t fs-type deviceext系列专用 mke2fs -t &#123;ext2、ext3、ext4&#125;： 指明文件系统类型 -b &#123;1024 | 2048 | 4096&#125;： 指明文件系统的块大小 -L LABEL： 指明卷标 -j： 创建有日志功能的文件系统ext3； mke2fs -j &#x3D; mke2fs -t ext3 &#x3D; mkfs.ext3 -i 每多少字节创建inode -N 直接指明要给此文件系统创建inode的数量； -O [^]FEATURE: 以指定的特性创建目标文件系统，不加拖字符表示启用，加拖字符表示关闭特性； -m 指定为超级用户保留的文件系统块的百分比。这样可以避免碎片，并允许root拥有的守护程序，默认为5%。 检测和修复12345678910111213fsck: 用于实现文件系统检测的工具；因进程意外中止或者系统崩溃等原因导致定稿操作非正常终止时，可能会造成文件损坏；此时，应该检测并修复文件系统；建议，离线进行（非挂载状态）；e2fsck: 检测ext2&#x2F;3&#x2F;4 文件系统错误e2fsck [option] device -y: 默认对所有问题自动回答yes； -f：及时文件系统处于clean状态，也check一遍；fsck: check and repair a Linux filesystem -t: fslist 指定文件系统类型； -a: 自动修复文件系统，不询问任何问题（请谨慎使用此选项）。 -r: 交互式修复； 查看属性12345678910111213141516dumpe2fs ：显示ext系列文件系统的属性信息； dumpe2fs [-h] devicetune2fs: 查看或者修改ext系列文件系统的某些属性。 tune2fs [option] device -l 查看超级块信息 修改： -j ext2升级为ext3，无损升级，有数据也可升级; -L LABEL: 修改卷标 -m 修改预留块的百分比； -O [^] 开启或者关闭某种特性； -o [^]mount_options：开启或者关闭某种默认挂载选项； acl&#x2F;^acl: 开启或者关闭aclblkid: 查找&#x2F;打印块设备属性 -L: 查找使用此文件系统标签的设备； -k: 列出所有已知的文件系统&#x2F; RAID并退出; 调整文件系统特性123e2label - 更改ext2 &#x2F; ext3 &#x2F; ext4文件系统上的卷标 查看：e2label device 设定：e2label device LABEL CentOS6 如何使用xfs文件系统：联网的话：yum install xfsprogs Swap 文件系统linux 的交换分区必须使用独立的文件系统且文件系统的system ID必须为82；创建Swap设备： 123mkswap [option] device -L LABEL: 指明卷标 -f： 强制 windows无法识别Linux的文件系统；因此，存储设备需要在两=两种系统之间交叉使用时，应该使用fat32（vfat）；mkfs.vfat device 练习1: 练习2:","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-05T13:44:34.961Z","updated":"2020-05-05T13:44:34.961Z","comments":true,"path":"2020/05/05/hello-world/","link":"","permalink":"http://lcxiao.ga/2020/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2020-05-05T08:44:14.000Z","updated":"2020-05-06T11:58:35.930Z","comments":true,"path":"2020/05/05/test/","link":"","permalink":"http://lcxiao.ga/2020/05/05/test/","excerpt":"","text":"This is a test file.","categories":[],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://lcxiao.ga/categories/Linux/"}],"tags":[{"name":"Bash -","slug":"Bash","permalink":"http://lcxiao.ga/tags/Bash/"}]}