---
title: 14.linux进程原理、类型和内核状态
date: 2020-06-15 13:08:34
layout:
updated:
comments:
categories:
tags:
---
软中断、发起内核调用；用户态，内核态，

系统调用：

用户模式（空间）、内核模式（空间）；

用户模式无法完成的操作，需要系统调用；实现模式切换；

内核的功用：进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能；

时间片：按时间片划分资源，

进程优先级概念：

内核负责进程调度，根据优先级调度资源；

进程的当前状态保存下来；

内核在进程切换时需要保存上一个进程运行的现场。保存现场；--> 恢复现场、切换太多会浪费时间；

进程--> 运行中的程序的一个副本：

存在生命周期：

每一个进程结构都相同

内核存储进程的格式：task struct

多个人的task struct组成的链表：链表：有先后次序、（循环链表、双向链表、双向循环链表）

任何进程、在内核无漏洞的情况下、无权运行特权指令；

如果要运行，会出发中断，会立即唤醒内核，内核处理中断；

进程创建：

启动启动时-->运行内核-->创建第一个进程（init）（初始化进程）表示内核空间和用户空间都已经创建，init是负责用户空间管理-->创建子进程

除了init（内核创建）之外，其余进程都是由父进程创建，fork（），clone（）父进程的内存空间也是子进程的内存空间，子进程创建数据需要写实复制。进程 必须是父进程给他销毁（白发送黑发）；子进程是为父进程完成特定任务，子进程任务时，父进程在等待状态，子进程任务结束后，父进程销毁，并继续往下走；

优先级：

0-139

1-99：实时优先级：数字越大--->优先级越高

100-139：静态优先级；用户可控的；，数字越小<----优先级越高；

NICE值：-20 ---- 19

​					|		|

​				100		139

可以调整一个进程的nice值来控制优先级；

Big O

O(1)、O(logn)、O(n),O(2^n)、O(n^2)

|

|——————————————O(1)

|

|——————————————



优先队列：

运行队列，过期队列；

进程结构：task struct

状态

flags

父进程

。。。



内核对内存的分配；

分割成内存片，一般为4k，页框，用存储页面数据；

每一个进程都以为自己是唯一的进程；

线性地址空间；

内核只给进程它所需要的；

虚拟内存空间；

堆栈

堆向栈增长，栈向堆生长；

LRU算法，最近最少使用，分配到交换分区；

MMU:Memory Management Unit:内存管理单元；

转换虚拟内存空间和物理内存的映射关系；

缺页；

常驻内存级；必须在内存

虚拟内存级：可被交换的内存空间；

IPC：Inter Press Communication 进程间通信；

同一主机上：

​	singal

​	shm：shared memory

​	semerphor：

跨主机：

RPC：remote procecure call：远程过程调用；

socket文件：记录自己和对方的端口；

​		A								B

|———|					  |———|

|socket|—————   |socket|

|———|				 	 |———|

​	|										|

​	|										|

内核									内核



Linux内核：抢占式多任务；

进程类型：

​	守护进程：daemon，在系统引导过程中启动的进程，跟终端无关的进程

​	前台进程：根终端有关，通过终端启动的进程；

​		注意，也可把在前台启动的进程送往后台，以守护模式运行；

进程状态：

​	运行态：running

​	就绪态：ready

​	睡眠态：

​		可中断:interruptable；

​		不可中端：uninterruptable；

​	停止态：暂停于内存中，但不会被调度，除非手动启动：stopped

​	僵尸态：zombie ，（子进程运行中，父进程突然就挂了）

进程的分类：

CPU-BOUND：cpu密集型进程（多分cpu）

IO-BOUND：IO密集型进程（提高优先级）



IO：进程运行过程中加载数据，IO分2段，1.数据从磁盘装入内核。2内核复制一份到内存中，

《《linux内核设计与实现》》。《《深入理解linux内核》》




