<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Lcxiao&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Lcxiao&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lcxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Lcxiao's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lcxiao's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lcxiao's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-lifestyle">

    <a href="/lifestyle/" rel="section"><i class="fa fa-fw fa-lifestyle"></i>LifeStyle</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/5-btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/5-btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">5.btrfs文件系统管理与应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 04:26:33 / 修改时间：12:29:09" itemprop="dateCreated datePublished" datetime="2020-06-01T04:26:33+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>技术预览版。GPL，开源版本 2007 ORACLE Cow；取代linux系统的ext系列文件系统<br><code>B-tree</code><br><code>Butter FS</code><br><code>Better FS</code></p>
<p><strong>特性</strong><br>多物理卷支持：可由多个底层物理卷组成，支持RAID，已联机添加、移除、修改；<br>写入时复制（cow）：复制、更新、以及替换指针；而非传统的“就地”更新；<br>数据及元数据校验码：checksum：极大的保证了数据的可靠性；<br>子卷：sub_volume；<br>快照：支持快照的快照；<br>透明压缩:节约时间，但是会浪费CPU时钟周期；<br><strong>btrfs</strong><br><strong>mkfs.btrfs</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># mkfs.btrfs </span></span><br><span class="line">btrfs-progs v4.9.1</span><br><span class="line">See http://btrfs.wiki.kernel.org <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">Usage: mkfs.btrfs [options] dev [ dev ... ]</span><br><span class="line">Options:</span><br><span class="line">  allocation profiles:</span><br><span class="line">        -d|--data PROFILE       data profile, raid0, raid1, raid5, raid6, raid10, dup or single</span><br><span class="line">        -m|--metadata PROFILE   metadata profile, values like <span class="keyword">for</span> data profile</span><br><span class="line">        -M|--mixed              mix metadata and data together</span><br><span class="line">  features:</span><br><span class="line">        -n|--nodesize SIZE      size of btree nodes</span><br><span class="line">        -s|--sectorsize SIZE    data block size (may not be mountable by current kernel)</span><br><span class="line">        -O|--features LIST      comma separated list of filesystem features (use <span class="string">'-O list-all'</span> to list features)</span><br><span class="line">        -L|--label LABEL        <span class="built_in">set</span> the filesystem label</span><br><span class="line">        -U|--uuid UUID          specify the filesystem UUID (must be unique)</span><br><span class="line">  creation:</span><br><span class="line">        -b|--byte-count SIZE    <span class="built_in">set</span> filesystem size to SIZE (on the first device)</span><br><span class="line">        -r|--rootdir DIR        copy files from DIR to the image root directory</span><br><span class="line">        -K|--nodiscard          <span class="keyword">do</span> not perform whole device TRIM</span><br><span class="line">        -f|--force              force overwrite of existing filesystem</span><br><span class="line">  general:</span><br><span class="line">        -q|--quiet              no messages except errors</span><br><span class="line">        -V|--version            <span class="built_in">print</span> the mkfs.btrfs version and <span class="built_in">exit</span></span><br><span class="line">        --<span class="built_in">help</span>                  <span class="built_in">print</span> this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">  deprecated:</span><br><span class="line">        -A|--alloc-start START  the offset to start the filesystem</span><br><span class="line">        -l|--leafsize SIZE      deprecated, <span class="built_in">alias</span> <span class="keyword">for</span> nodesize</span><br></pre></td></tr></table></figure>

<p>-L <code>LABEL</code></p>
<p>-d <type>: raid0, raid1, raid5, raid6, raid10, single, dup</p>
<p>-O <feature>: raid0, raid1, raid5, raid6, raid10, single, dup</p>
<p>​    -O list-all: 列出支持的所有feature；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># mkfs.btrfs -O list-all</span></span><br><span class="line">Filesystem features available:</span><br><span class="line">mixed-bg            - mixed data and metadata block groups (0x4, compat=2.6.37, safe=2.6.37)</span><br><span class="line">extref              - increased hardlink <span class="built_in">limit</span> per file to 65536 (0x40, compat=3.7, safe=3.12, default=3.12)</span><br><span class="line">raid56              - raid56 extended format (0x80, compat=3.9)</span><br><span class="line">skinny-metadata     - reduced-size metadata extent refs (0x100, compat=3.10, safe=3.18, default=3.18)</span><br><span class="line">no-holes            - no explicit hole extents <span class="keyword">for</span> files (0x200, compat=3.14, safe=4.0)</span><br></pre></td></tr></table></figure>

<p><code>mkfs.btrfs -L mydata /dev/sdb /dev/sdc -f</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># mkfs.btrfs -L mydata /dev/sdb /dev/sdc -f</span></span><br><span class="line">btrfs-progs v4.9.1</span><br><span class="line">See http://btrfs.wiki.kernel.org <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">Label:              mydata</span><br><span class="line">UUID:               7c9e06ee-52ee-4350-b066-d23e980f6b88</span><br><span class="line">Node size:          16384</span><br><span class="line">Sector size:        4096</span><br><span class="line">Filesystem size:    20.00GiB</span><br><span class="line">Block group profiles:</span><br><span class="line">  Data:             RAID0             2.00GiB</span><br><span class="line">  Metadata:         RAID1             1.00GiB</span><br><span class="line">  System:           RAID1             8.00MiB</span><br><span class="line">SSD detected:       no</span><br><span class="line">Incompat features:  extref, skinny-metadata</span><br><span class="line">Number of devices:  2</span><br><span class="line">Devices:</span><br><span class="line">   ID        SIZE  PATH</span><br><span class="line">    1    10.00GiB  /dev/sdb</span><br><span class="line">    2    10.00GiB  /dev/sdc</span><br></pre></td></tr></table></figure>

<p>显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># btrfs filesystem show</span></span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 7c9e06ee-52ee-4350-b066-d23e980f6b88</span><br><span class="line">        Total devices 2 FS bytes used 112.00KiB</span><br><span class="line">        devid    1 size 10.00GiB used 2.01GiB path /dev/sdb</span><br><span class="line">        devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br></pre></td></tr></table></figure>



<p>之后就可以挂载使用了</p>
<p><code>mount -t btrfs /dev/sdc MOUNT_POINT</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># mkdir -pv /mnt/mydata</span></span><br><span class="line">mkdir: created directory ‘/mnt/mydata’</span><br><span class="line">[root@Centos7 ~]<span class="comment"># mount -t btrfs /dev/sd</span></span><br><span class="line">sda   sda1  sda2  sda3  sdb   sdc</span><br></pre></td></tr></table></figure>

<p>只要使用sdb和sdc效果一样</p>
<p><code>/dev/sdb on /mydata type btrfs (rw,relatime,seclabel,space_cache,subvolid=5,subvol=/)</code></p>
<p>卸载umount即可</p>
<p>透明压缩机制：</p>
<p><code>mount -o compress={lzo|zlib} DEVICE MOUNT_POINT</code></p>
<p><code>btrfs resize</code></p>
<p>增加：</p>
<p><code>btrfs device add /dev/sd? mount_point</code></p>
<p>balance均衡操作：</p>
<p><code>btrfs balance {status|start|pause|cancel|resume}</code></p>
<p>联机拆除设备，不影响数据，会自动移动文件</p>
<p><code>btrfs device delete /dev/sd? mount_point</code></p>
<p>改变raid级别</p>
<p><code>btrfs balance start -dconvert=raid5 /mydata</code>    数据块的</p>
<p><code>btrfs balance start -mconvert=raid5 /mydata</code> 元数据的</p>
<p>子卷：</p>
<p><code>btrfs subvolume</code></p>
<p>创建：create</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos7 ~]<span class="comment"># btrfs subvolume create /mydata/logs</span></span><br><span class="line">Create subvolume <span class="string">'/mydata/logs'</span></span><br></pre></td></tr></table></figure>

<p>列出；</p>
<p>list</p>
<p><code>btrfs subvolume list /mydata</code></p>
<p>只挂载子卷：</p>
<p>先卸载父卷</p>
<p><code>mount -o subvol=logs /dev/sdb /mydata/</code></p>
<p>使用子卷ID挂载：</p>
<p><code>mount -o subvolid=1 /dev/sdb /mydata</code></p>
<p>子卷删除：</p>
<p><code>btrfs subvolume delete /mydata/logs</code> </p>
<p>创建快照：</p>
<p>子卷的快照必须与子卷在一个父卷中：</p>
<p><code>btrfs subvolume snapshot /mydata/logs /mydata/log_snapshot</code></p>
<p>删除:</p>
<p><code>btrfs subvolume delete /mydata/logs_snapshot/</code></p>
<p>对一个文件创建快照：</p>
<p>cp –reflink file file_snapshot</p>
<p>另一个文件最好在当前卷下某个路径下</p>
<p>无损转换文件系统：</p>
<p>ext4转换为btrfs</p>
<p><code>fsck -f device</code></p>
<p><code>btrfs-convert device</code></p>
<p>回滚为ext4</p>
<p><code>btrfs-convert -r device</code></p>
<p><code>blkid</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/4-Linux%E5%AE%9E%E7%8E%B0LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%8F%8A%E5%BF%AB%E7%85%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/4-Linux%E5%AE%9E%E7%8E%B0LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E5%8F%8A%E5%BF%AB%E7%85%A7/" class="post-title-link" itemprop="url">Linux实现LVM逻辑卷及快照</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 04:26:12 / 修改时间：12:28:23" itemprop="dateCreated datePublished" datetime="2020-06-01T04:26:12+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LVM2"><a href="#LVM2" class="headerlink" title="LVM2"></a>LVM2</h1><p>Logical Volume Manager, Version2;</p>
<p>dm device mapper:<br>将一个或者多个底层块设备组织成一个逻辑设备;</p>
<h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>查看 :<br>    pvs    #简要;<br>    pvdisplay   #详细;<br>创建 :<br>    pvcreate /dev/DEVICE </p>
<h2 id="VG"><a href="#VG" class="headerlink" title="VG"></a>VG</h2><p><strong>查看:</strong><br>    vgs<br>    vgdisplay<br><strong>创建:</strong><br>    vgcreate VG_NAME PV_DEVICE</p>
<p>-s PE大小</p>
<p>-P 最大PV数</p>
<p><strong>例如：</strong></p>
<p>vgcreate myvg /dev/sdb1 /dev/sdc1</p>
<p>扩展：<br>    vgextend vgNAME PhysicalDevicePath [PhysicalDevicePath] #扩展;<br>缩减：<br>    vgreduce vgNAME PhysicalDevicePath [PhysicalDevicePath] #缩减;<br><strong>修改</strong><br><strong>删除</strong><br>顺序执行<br>    lvremove<br>    vgremove<br>    pvremove</p>
<h2 id="LV"><a href="#LV" class="headerlink" title="LV"></a>LV</h2><p><strong>查看</strong><br>    lvs #简要;<br>    lvdisplay   #详细;<br><strong>创建</strong><br>    lvcreate -L #[mMgGtT] -n NAME VolumeGroup(VG) </p>
<p><strong>修改</strong><br>扩容：</p>
<ol>
<li><p>逻辑边界 </p>
</li>
<li><p>物理空间<br>lvextend -L #目标大小 [+][mMgGtT] #要增加的大小 /dev/VG_NAME/LV_NAME #扩展物理大小;</p>
<p>example: lvextend –size +2g /dev/testvg/testlv</p>
</li>
<li><p>resize2fs /dev/VG_NAME/LV_NAME  #重新设置分区大小;</p>
</li>
</ol>
<p>缩减：</p>
<ol>
<li>逻辑边界 #先卸载文件系统，离线进行，在线有文件丢失风险;</li>
<li>物理空间<br>umount /dev/VG_NAME/LV_NAME<br>e2fsck -f /dev/VG_NAME/LV_NAME<br>resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]<br>lvreduce -L [-][mMgGtT] /dev/VG_NAME/LV_NAME    #注意 <code>-L</code> 和 + 的区别；# 如果是其他文件系统，使用其他工具;<br>mount<br>删除：<br>lvremove /dev/VG_NAME/LV_NAME<br>vgremove<br>pvremove</li>
</ol>
<h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1:"></a>练习1:</h2><p>创建一个至少有两个PV组成的大小为20G的名为testvg的VG；要求PE大小为16MB；<br>而后在卷组中创建大小为5G的逻辑卷testlv；挂载至/users目录；</p>
<p><code>pvcreate /dev/sdb1 /dev/sdc1</code></p>
<p><code>vgcreate -s 16m testvg /dev/sdb1 /dev/sdc1</code></p>
<p><code>lvcreate -L 5G -n testlv testvg</code></p>
<p><code>mkfs -v -t ext4 /dev/mapper/testvg-testlv</code></p>
<p><code>mkdir -pv /users</code></p>
<p><code>mount /dev/mapper/testvg-testlv /users/</code></p>
<p>练习2：<br>新建用户archlinux，要求其家目录为/users/archlinux, 而后su切换至archlinux用户，复制/etc/pam.d目录至自己的家目录；</p>
<p><code>mkdir -pv /users/archlinux</code></p>
<p><code>useradd -d /users/archlinux/ archlinux</code></p>
<p><code>su archlinux</code></p>
<p><code>cp -av /etc/pam.d ~</code></p>
<p>练习3：扩展testlv至7G，要求archlinux用户的文件不能丢失；</p>
<p>umount /dev/mapper/testvg-testlv</p>
<p>lvextend -L 7g /dev/testvg/testlv</p>
<p>e2fsck -f /dev/mapper/testvg-testlv</p>
<p>resize2fs /dev/mapper/testvg-testlv 7g</p>
<p>mount /dev/mapper/testvg-testlv /users/</p>
<p>练习4：收缩testlv至3G，要求archlinux用户的文件不能丢失；</p>
<p>umount /dev/mapper/testvg-testlv<br>e2fsck -f /dev/mapper/testvg-testlv<br>resize2fs /dev/mapper/testvg-testlv 3g<br>lvreduce -L 3g /dev/testvg/testlv<br>mount /dev/mapper/testvg-testlv /users/</p>
<h2 id="文件系统挂载使用中的问题："><a href="#文件系统挂载使用中的问题：" class="headerlink" title="文件系统挂载使用中的问题："></a>文件系统挂载使用中的问题：</h2><p>挂载光盘设备：<br>光盘设备文件: /dev/<br>    IDE: /dev/hdc<br>    SATA: /dev/sr0<br>符号链接文件：<br>    /dev/cdrom<br>    /dev/dvdrom<br>    /dev/dvd</p>
<p>挂载：<br>mkdir -pv /medir/cdrom<br>mount -r /dev/sr0 /media/cdrom</p>
<p>U 盘的挂载：<br>新挂载的设备，以大小来判断：<br>    /dev/sdx<br>    fdisk -l</p>
<p>一个小命令的应用<br>DD： 一个实现文件底层拷贝的工具<br>复制命令<br>convert and copy a file<br>用法：<br>dd if=/PATH/FROM/SRC of=/PATH/TO/DEST<br>bs=# blocksize 块大小 默认为字节；<br>count=# 数量 多少个上面的块；<br>因为是复制的底层实现，所以拷贝效率高：<br>直接拷贝磁盘：<br>dd if=/dev/sda of=/dev/sdb</p>
<p>备份MBR<br>dd if=/dev/sda of=/mbr.bak bs=512 count=1</p>
<p>损坏MBR #瞬间让一个磁盘分区表失效<br>dd if=/dev/zero of=/dev/sda bs=512 count=1</p>
<p>精准破坏BootLoader：<br>dd if=/dev/zero of=/dev/sda bs=256 count=1</p>
<h2 id="两个特殊设备："><a href="#两个特殊设备：" class="headerlink" title="两个特殊设备："></a>两个特殊设备：</h2><p>/dev/null   数据黑洞<br>/dev/zero   吐零机</p>
<p>测试硬盘系统读写速度：<br>dd if=/dev/zero of=/dev/null bs=1G count=2</p>
<h1 id="快照：-snapshot"><a href="#快照：-snapshot" class="headerlink" title="快照： snapshot"></a>快照： snapshot</h1><p>对文件系统做快照，相当于对文件系统在某一时间做一次快速扫描，<br>备份<br>序列化<br>文件序列化后如何还原；<br>因为备份的时间短，在备份时后面的数据如果发生改变的话，会造成备份后的数据和原来想要备份的不一样<br>所以需要对文件做一次快照；<br>快照卷，类似于硬链接，执行原来的文件，本来是不存在任何数据的，监控原数据，任何时刻，当文件要变化时，拷贝一份；</p>
<p>使用 LVM 创建 Linux 快照<br><code>lvcreate -s [-L &lt;size&gt;] -n SNAP_VOLUME SOURCE_VOLUME_PATH</code><br>如果不指定大小，快照会创建为瘦快照。<br><code>lvcreate -s -L 1G -n linux01-snap /dev/lvm/linux01</code><br>快照将被创建为 /dev/lvm/linux01-snap 卷。</p>
<p>-p #读写权限 -s -n snapshot_lv_name </p>
<p>监视快照<br><code>lvdisplay SNAP_VOLUME</code></p>
<p>删除 Linux 快照<br><code>lvremove SNAP_VOLUME_PATH</code></p>
<p>例如：<br><code>sudo lvremove /dev/lvmvg/linux01-snap</code></p>
<p>存储快照的原理：</p>
<p><img src="https://pic3.zhimg.com/v2-dbdc599a74b0cfa0b311e56e2642797d_1200x500.gif" alt=""><br>快照是完全可用的拷贝，但不是一份完整的拷贝;</p>
<p>存储快照的使用场景:<br>场景一：<br>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护，通俗地讲，可以理解为—-后悔药。<br><img src="https://pic1.zhimg.com/80/v2-ce2e26a65fb74f821def18ff0c9fc0d4_720w.jpg" alt=""><br>如上图，假设在t0时刻，有一份完整的源数据，我们在t1时刻，针对这份源数据创建一份快照。</p>
<p>t2时刻，若因为各种原因（误操作、系统错误等）导致源数据损毁，那么，我们可以通过回滚（rollback）快照，将源数据恢复至快照创建时的状态（即t1时刻），这样，可以尽量降低数据损失（损失的数据，是t1到t2之间产生的数据）。</p>
<p>这种功能，常用于银行、公安户籍、科研单位等。操作系统、软件升级或机房设备更替，一般会选择在夜间或其他无生产业务时，进行高危操作，操作前会对数据进行快照，若操作失败，则将快照进行rollback，将源数据恢复至操作前的状态。</p>
<p>场景2：<br>前面说过，快照是一份完全可用的副本，那么，它完全可以被上层业务当做源数据;<br><img src="https://pic2.zhimg.com/80/v2-c19d1d2e7e3ac832c3e1887294ce1231_720w.jpg" alt=""><br>如上图，针对源数据，创建快照后，将快照卷映射给其他上层业务，可以用于数据挖掘和开发测试等工作，针对快照的读操作不影响源卷的数据。</p>
<p>这种功能，常用于直播（视频&amp;图片）鉴黄、科研数据模拟开发测试等，比如，视频直播平台需要将某一段时间的视频提供给执法机构进行筛查分析，那么可以通过对特定时间点保存的数据创建快照，将快照映射给执法机构的业务主机去进行挖掘分析。</p>
<p>存储快照的实现原理<br>目前，快照的实现方式均由各个厂商自行决定，但主要技术分为2类，一种是写时拷贝COW（Copy On Write），另一种，是写重定向ROW（Redirect On Write）。</p>
<p>写时拷贝COW<br>COW(Copy-On-Write)，写时拷贝，也称为写前拷贝。<br>创建快照以后，如果源卷的数据发生了变化，那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中，然后再对源卷进行改写。<br><img src="https://pic3.zhimg.com/v2-cf04fb26d7526ece20fda116c47aa936_b.webp" alt=""></p>
<p>写操作：</p>
<p>如上图简要示例，快照创建以后，若上层业务对源卷写数据X，X在缓存中排队，快照系统将X即将写入的位置（逻辑地址）上的数据Y，拷贝到快照卷中对应的位置（逻辑地址）上，同时，生成一张映射表，表中一列记录源卷上数据变化的逻辑地址，另一列记录快照卷上数据变化的逻辑地址。我们可以看到，上层业务每下发一个数据块，存储上，发生了两次写操作：一次是源卷将数据写入快照卷（即图中Y），一次是上层业务将数据写入源卷（即图中X）。<br><img src="https://pic4.zhimg.com/v2-d65390e6faee92f05481f56c203edc5f_b.webp" alt=""></p>
<p>读操作：</p>
<p>如上图，快照卷若映射给上层业务进行数据分析等用途时，针对快照进行读操作时，首先由快照系统判断，上层业务需要读取的数据是否在快照卷中，若在，直接从快照卷读取，若不在，则查询映射表，去对应源卷的逻辑地中读取（这个查表并去源卷读的操作，也叫读重定向）。这一点，恰好就解释了为什么快照是一份完全可用的副本，它没有对源卷进行100%的拷贝，但对上层业务来说，却可以将快照看做是和源卷“一模一样”的副本。</p>
<p>针对源卷进行读操作时，与快照卷没有数据交互。</p>
<p>我们可以看到，快照对源卷的数据具有很好的保护措施，快照可以单独作为一份可以读取的副本，但并没有像简单的镜像那样，一开始就占用了和源卷一样的空间，而是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。</p>
<p>快照回滚（rollback）：<br><img src="https://pic1.zhimg.com/v2-c1865d4d0044c54fc857adb9956511a0_b.webp" alt=""></p>
<p>如上图，回滚操作的前提条件是，锁定源卷（暂停对待回滚的逻辑地址上的IO操作），然后通过查映射表，将快照卷上的对应数据回拷到源卷中。</p>
<p>快照删除：</p>
<p>采用COW技术的快照，其源卷即保存着完整的实时数据，因此，删除快照时，直接销毁了快照卷和映射表，与源卷不存在数据交互。</p>
<p>写时重定向ROW<br>ROW(Redirect-on-write )，也称为写时重定向。</p>
<p>创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，直接将新的数据写入快照卷。上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读。<br><img src="https://pic2.zhimg.com/v2-e5f7abc31f11459d563eee8cd9cae269_b.webp" alt=""></p>
<p>写操作：</p>
<p>如上图简要示例，快照创建以后，若上层业务对源卷写数据X，X在缓存中排队，快照系统判断X即将写入源卷的逻辑地址，然后将数据X写入快照卷中预留的对应逻辑地址中，同时，将源卷和快照卷的逻辑地址写入映射表，即写重定向。我们可以看到，上层针对源卷写入一个数据块X，存储上只发生一次写操作，只是写之前进行了重定向。</p>
<p>读操作：</p>
<p>若快照创建以后，上层业务对源卷进行读，则有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么，上层就从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就查询映射表，从快照卷进行读取（即读重定向）。</p>
<p>若快照创建以后，上层业务对快照卷进行读，同样也有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么上层就查询映射表，从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就直接从快照卷进行读取。</p>
<p>我们可以看到，ROW快照也是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。</p>
<p>快照回滚（rollback）：</p>
<p>采用ROW技术的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中，因此，快照的回滚只是取消了对源卷的读重定向操作。通俗地说，就是源卷上没有进行任何数据操作，上层业务对源卷的读，仅限于读源卷（即不会去读取快照卷的数据）。</p>
<p>快照删除：<br><img src="https://pic4.zhimg.com/v2-ff2b6084856227cde5386203a2ca6183_b.webp" alt=""><br>采用ROW技术的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中。因此，若要删除快照，必然要先将快照卷中的数据，回拷到源卷中，拷贝完成才能删除，如上图。此时我们可以设想，如果，针对一份源数据，在18:00创建了快照，上层业务持续产生大量新的数据，19:00又创建了快照，20:00又创建了快照……那么，在有多份快照的情况下，如果需要删除快照，就会出现，多个快照向源卷回拷数据的情况，可能导致回拷量非常大，耗时很长。</p>
<p>两种技术对比<br><img src="https://pic3.zhimg.com/80/v2-948ac88dbe0a3cd5adb5e4554e73735e_720w.jpg" alt=""></p>
<p>如上表，COW的写时拷贝，导致每次写入都有拷贝操作，大量写入时，源卷的写性能会有所下降，而读源卷是不会受到任何影响的，删除快照时，只是解除了快照和源卷的关系，同时删除了快照卷的数据而已。ROW在每次写入仅做了重定向操作，这个操作耗时是几乎可以忽略不计的，源卷的写性能几乎不会受到影响，但读源卷时，则需要判断数据是创建快照前还是创建快照后，导致大量读时，性能受到一定影响，比较致命的是，若源卷有多个快照，在删除快照时，所有快照的数据均需要回拷到源卷才可以保证源卷数据的完整性。</p>
<p>总结：<br>上面简单地介绍了存储快照的实现原理，实际上，快照特性应用广泛，其应用对象是很多的：<br><img src="https://pic4.zhimg.com/80/v2-35e470c5846221bd84c836f117457d73_720w.jpg" alt=""></p>
<p>目前，主流厂商在自研产品上，对上面的ROW和COW技术都有小范围的改动，也有一些新兴的快照技术已经诞生，但这个行业里，没有最好的快照技术。技术为业务服务，只有针对业务类型做好本地化适配，才能达到最佳效用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/39916936" target="_blank" rel="noopener">知乎：揭秘：存储快照的实现</a><br><a href="https://documentation.suse.com/zh-cn/sles/12-SP4/html/SLES-all/cha-lvm-snapshots.html" target="_blank" rel="noopener">LVM 卷快照</a><br><a href="https://documentation.suse.com/zh-cn/sles/12-SP4/html/SLES-all/part-lvm.html" target="_blank" rel="noopener">逻辑卷 (LVM)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/3-Linux%E5%B9%B3%E5%8F%B0RAID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/3-Linux%E5%B9%B3%E5%8F%B0RAID/" class="post-title-link" itemprop="url">Linux平台RAID</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 13:23:39 / 修改时间：21:58:39" itemprop="dateCreated datePublished" datetime="2020-05-06T13:23:39+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p><code>R</code>edundant <code>A</code>rray of <code>I</code>ndependent <code>D</code>isks <code>独立硬盘冗余阵列</code>,旧称<code>廉价磁盘冗余阵列</code>.<br>简称<code>磁盘阵列</code>。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。</p>
<p>在运作中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID 0、RAID 1、RAID 5、RAID 6、RAID 7、RAID 01、RAID 10、RAID 50、RAID 60。每种等级都有其理论上的优缺点，不同的等级在两个目标间获取平衡，分别是增加数据可靠性以及增加存储器（群）读写性能。</p>
<p>简单来说，RAID把多个硬盘组合成为一个逻辑硬盘，因此，操作系统只会把它当作一个实体硬盘。RAID常被用在服务器电脑上，并且常使用完全相同的硬盘作为组合。由于硬盘价格的不断下降与RAID功能更加有效地与主板集成，它也成为普通用户的一个选择，特别是需要大容量存储空间的工作，如：视频与音频制作。</p>
<table>
<thead>
<tr>
<th>RAID等级</th>
<th>最少硬盘</th>
<th>最大容错</th>
<th>可用容量</th>
<th>读取性能</th>
<th>写入性能</th>
<th>安全性</th>
<th>目的</th>
<th>应用产业</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>一个硬盘异常，全部硬盘都会异常</td>
<td>追求最大容量、速度</td>
<td>影片剪接缓存用途</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>n-1</td>
<td>1</td>
<td>n</td>
<td>1</td>
<td>高，一个正常即可</td>
<td>追求最大安全性</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
<td>n-1</td>
<td>n-1</td>
<td>n-1</td>
<td>高</td>
<td>追求最大容量、最小预算</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
<td>n-2</td>
<td>n-2</td>
<td>n-2</td>
<td>安全性较RAID 5高</td>
<td>同RAID 5，但较安全</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>10</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>高</td>
<td>综合RAID 0/1优点，理论速度较快</td>
<td>大型数据库、服务器</td>
</tr>
<tr>
<td>50</td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>高</td>
<td>提升数据安全</td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>高</td>
<td>提升数据安全</td>
<td></td>
</tr>
<tr>
<td>单一硬盘</td>
<td>(参考)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>无</td>
<td></td>
<td></td>
</tr>
<tr>
<td>jBOD</td>
<td>1</td>
<td>0</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>无（同RAID 0）</td>
<td>增加容量</td>
<td>个人（暂时）存储备份</td>
</tr>
</tbody></table>
<h2 id="标准RAID"><a href="#标准RAID" class="headerlink" title="标准RAID"></a>标准RAID</h2><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><pre><code>1. n代表硬盘总数
2. JBOD（Just a Bunch Of Disks）指将数个物理硬盘，在操作系统中合并成一个逻辑硬盘，以直接增加容量
3. 依不同 RAID 厂商实现算法对于性能表现会有不同，性能公式仅供参考
4. RAID 10、50、60 依实现 Parity 不同公式也不同</code></pre><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>它将两个以上的磁盘并联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，<code>RAID 0的速度是最快的</code>。但是<code>RAID 0既没有冗余功能</code>，也<code>不具备容错能力</code>，如果一个磁盘（物理）损坏，所有数据都会丢失。</p>
<p>读写性能提升：<br>可用空间：N*min(S1,S2…)<br>无容错能力<br>最小磁盘数:2</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RAID_0.svg/130px-RAID_0.svg.png" alt=""></p>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p>两组以上的N个磁盘相互作镜像，在一些多线程操作系统中能有很好的读取速度，<code>理论上读取速度等于硬盘数量的倍数</code>，与RAID 0相同。另外<code>写入速度有微小的降低</code>。只要一个磁盘正常即可维持运作，<code>可靠性最高</code>。其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以<code>RAID 1的数据安全性在所有的RAID级别上来说是最好的</code>。但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中<code>磁盘利用率最低的一个级别</code>。</p>
<p>读性能提升、写性能略微下降：<br>可用空间：1*min(S1,S2…)<br>有冗余能力<br>最少磁盘数：2</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/RAID_1.svg/130px-RAID_1.svg.png" alt=""></p>
<h3 id="RAID-2-不常见"><a href="#RAID-2-不常见" class="headerlink" title="RAID 2 (不常见)"></a>RAID 2 (不常见)</h3><p>这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分割为独立的比特，并将数据分别写入硬盘中。因为在数据中加入错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些。</p>
<p>RAID 2最少要三台磁盘驱动器方能运作。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/RAID2_arch.svg/300px-RAID2_arch.svg.png" alt=""></p>
<h3 id="RAID-3-不常见"><a href="#RAID-3-不常见" class="headerlink" title="RAID 3 (不常见)"></a>RAID 3 (不常见)</h3><p>采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/RAID_3.svg/220px-RAID_3.svg.png" alt=""></p>
<h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h3><p>它与RAID 3不同的是它在分割时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）<br>1101,0110,1011</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/RAID_4.svg/220px-RAID_4.svg.png" alt=""></p>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分割）技术。</p>
<p>RAID 5至少需要三个硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。RAID 5可以理解为是RAID 0和RAID 1的折衷方案。RAID 5可以为系统提供数据安全保障，但保障程度要比镜像低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用“回写缓存”可以让性能改善不少。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较便宜。</p>
<p>读写性能提升<br>可用空间：(N-1)*min(S1,S2…)<br>有容错能力，1块硬盘<br>最少磁盘数3</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/RAID_5.svg/220px-RAID_5.svg.png" alt=""></p>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p>读写性能提升<br>可用空间：(N-2)*min(S1,S2…)<br>有容错能力，2块硬盘<br>最少磁盘数4</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/RAID_6.svg/270px-RAID_6.svg.png" alt=""></p>
<h2 id="混合RAID"><a href="#混合RAID" class="headerlink" title="混合RAID"></a>混合RAID</h2><h3 id="JBOD"><a href="#JBOD" class="headerlink" title="JBOD"></a>JBOD</h3><p>just a bunch of disks<br>功能：将多块硬盘的空间合并一个大的连续空间使用；<br>可用功能：sum(S1,S2…)<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/JBOD.svg/175px-JBOD.svg.png" alt=""></p>
<h3 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h3><p>读写性能提升<br>可用空间：N*min(S1,S2…)/2<br>有容错能力：每组镜像最多只能坏一块；<br>最少磁盘数4</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/RAID_10.svg/220px-RAID_10.svg.png" alt=""></p>
<h3 id="RAID-01"><a href="#RAID-01" class="headerlink" title="RAID 01"></a>RAID 01</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/RAID_01.svg/220px-RAID_01.svg.png" alt=""></p>
<h3 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/RAID_50.png/500px-RAID_50.png" alt=""></p>
<h3 id="RAID-60"><a href="#RAID-60" class="headerlink" title="RAID 60"></a>RAID 60</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Raid_60.jpg/300px-Raid_60.jpg" alt=""></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>RAID2、3、4较少实际应用，因为RAID0、RAID1、RAID5、RAID6和混合RAID已经涵盖所需的功能，因此RAID2、3、4大多只在研究领域有实现，而实际应用上则以RAID0、RAID1、RAID5、RAID6和混合RAID为主。</p>
<p>RAID4有应用在某些商用机器上，像是NetApp公司设计的NAS系统就是使用RAID4的设计概念。</p>
<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>根据实现模式，分为软件和硬件两种：<br><code>CentOS6</code>上面 软件方式实现：<br>结合内核中的<code>md(multi devices)</code><br><code>mdadm</code> 模式化的工具</p>
<p>命令的语法格式： <code>mdadm [mode] &lt;raiddevice&gt; [options] &lt;componet-devices&gt;</code><br>支持的RAID级别：<code>LINEAR,RAID0,RAID1,RAID4,RAID5,RAID6,RAID10</code>;</p>
<p>模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建： -C</span><br><span class="line">装配： -A</span><br><span class="line">监控： -F</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">管理： -f， -r， -a</span><br><span class="line">    &lt;raiddevice&gt;: &#x2F;dev&#x2F;md#</span><br><span class="line">    &lt;component-devices&gt;: 任意块设备</span><br><span class="line"></span><br><span class="line">-C: 创建模式：</span><br><span class="line">    -n #: 使用#个块设备来创建此RAID；</span><br><span class="line">    -l #: 指明要创建的RAID的级别；</span><br><span class="line">    -a:  &#123;yes| no&#125; 自动创建目标RAID设备的设备文件；</span><br><span class="line">    -c: CHUNK_SIZE 指定块大小</span><br><span class="line">    -x: 指明空闲盘的个数</span><br></pre></td></tr></table></figure>

<p><strong>例如：创建一个10G可用空间的RAID5；</strong></p>
<p>创建<br><code>mdadm -C /dev/md0 -a yes -n 3 -x 1 -l 5 /devsda{7,8,9,10}</code><br>格式化<br><code>mkfs -v -t ext4 /dev/md0</code><br>挂载使用：<br><code>mount /dev/md0 MOUNT_POINT</code></p>
<p><strong>显示设备信息:</strong><br>-D：显示RAID的详细信息；<br><code>mdadm -D /dev/md#</code></p>
<p><strong>管理模式：</strong><br>-f 标记指定磁盘为损坏；<br><code>mdadm /dev/md0 -fdev/sda#</code></p>
<p>-a 添加磁盘<br><code>mdadm /dev/md0 -adev/sda#</code></p>
<p>-r 移除磁盘<br><code>mdadm /dev/md0 -rdev/sda#</code></p>
<p>观察md的状态；<br><code>cat /proc/mdstat</code></p>
<p>停止md设备<br><code>mdadm -S /dev/md#</code></p>
<p><strong>先卸载设备</strong><br><code>umount /dev/md0</code><br><code>mdadm -S /dev/md0</code></p>
<p>watch 命令：<br><code>-n # 刷新间隔，单位是秒</code><br><code>watch -n# &quot;command&quot;</code></p>
<p>练习1：创建一个可用空间为10G的RAID1设备，要求其chunk大小为128k，文件系统为ext4，有一个空闲盘，开机可自动挂载至/backup目录；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C /dev/md0 -c 128K -x 1 -n 2 -l 1 -a yes /deb/sda&#123;5,6,7&#125;</span><br><span class="line">mkfs -v -t ext4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"`blkid /dev/md0 | awk '&#123;print <span class="variable">$3</span>&#125;'` /backup ext4 defaults 0 0"</span> &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>

<p>练习2：创建一个可用空间为10G的RAID10设备，要求chunk大小为256k，文件系统为ext4，开机可自动挂载至/mydata目录；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C /dev/md0 -c 256K -n 4 -l 10 -a yes /dev/sdb&#123;7,8,9,10&#125;</span><br><span class="line">mkfs -v -t ext4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"`blkid /dev/md0 | awk '&#123;print <span class="variable">$3</span>&#125;'` /mydata ext4 defaults 0 0"</span> &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>

<h3 id="磁盘阵列相关客户类型"><a href="#磁盘阵列相关客户类型" class="headerlink" title="磁盘阵列相关客户类型"></a>磁盘阵列相关客户类型</h3><ul>
<li>一般消费者备份数据之用、企业创建ERP系统或NAS系统时的重要数据备份。</li>
<li>影音多媒体数字内容创作公司、个人影音剪辑数字内容工作室、摄影工作室、摄影公司。</li>
<li>电视台、广播电台及互联网内容提供商等传统媒体及新媒体。</li>
<li>数字监控系统（DVR）、网络监控系统（NVR）等等需要大量存储影片的监控系统业者，军方、赌场因为需要大量监控系统也是常见使用磁盘阵列的客户。</li>
<li>证券、银行等金融行业保管重要客户数据。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.archlinux.org/index.php/RAID_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Arch Wiki</a></p>
<h2 id="常用级别："><a href="#常用级别：" class="headerlink" title="常用级别："></a>常用级别：</h2><p>RAID-0、RAID-1、RAID-5、RAID-10、RAID-50、JBOD</p>
<h2 id="RAID各级别特性"><a href="#RAID各级别特性" class="headerlink" title="????RAID各级别特性"></a>????RAID各级别特性</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/101-progit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/101-progit/" class="post-title-link" itemprop="url">progit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 13:23:11 / 修改时间：21:58:39" itemprop="dateCreated datePublished" datetime="2020-05-06T13:23:11+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>版本控制–&gt; 版本控制系统–&gt;本地版本控制系统–&gt;集中化的版本控制系统–&gt;分布式版本控制系统</p>
<h1 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h1><p>分布式版本控制系统<br>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像 下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像 出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p>
<ul>
<li>直接记录快照，而非差异比较  <em>快照流</em></li>
<li>近乎所有操作都是本地执行</li>
<li>Git 保证完整性 <ul>
<li>Git 用以计算校验和的机制叫做 SHA-1 散列</li>
<li>Git 数据库中保存的信息都是以文件内 容的哈希值来索引，而不是文件名.</li>
</ul>
</li>
<li>Git 一般只添加数据 </li>
</ul>
<h1 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h1><ul>
<li>已提交（committed）<ul>
<li>已提交表示数据已经安全地保存在本地数据库中.</li>
</ul>
</li>
<li>已修改（modified）<ul>
<li>修改了文件，但还没保存到数据库中。</li>
</ul>
</li>
<li>已暂存（staged）<ul>
<li>示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 </li>
</ul>
</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p>
<p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上 供你使用或修改。 </p>
<p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索 引”，不过一般说法还是叫“暂存区”。 </p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆 仓库时，复制的就是这里的数据。 </p>
<h1 id="基本的-Git-工作流程如下："><a href="#基本的-Git-工作流程如下：" class="headerlink" title="基本的 Git 工作流程如下："></a>基本的 Git 工作流程如下：</h1><ol>
<li>在工作区中修改文件。 </li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 </li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 <code>已提交</code> 状态。 如果文件已修改并放入暂存区，就属于 <code>已暂存</code> 状 态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <code>已修改</code> 状态.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>从源代码安装 :<br>从源码安装 Git，需要安装 Git 依赖的库：autotools、curl、zlib、openssl、expat 和 libiconv。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \   openssl-devel perl-devel zlib-devel </span><br><span class="line">$ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \   </span><br><span class="line">gettext libz-dev libssl-dev</span><br></pre></td></tr></table></figure>

<p>为了添加文档的多种格式（doc、html、info），需要以下附加的依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install asciidoc xmlto docbook2X </span><br><span class="line">$ sudo apt-get install asciidoc xmlto docbook2x</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 RHEL 和 RHEL 衍生版，如 CentOS 和 Scientific Linux 的用户需要 开启 EPEL 库 以便下 载 docbook2X 包。 </p>
</blockquote>
<p>使用基于 Debian 的发行版（Debian/Ubuntu/Ubuntu-derivatives），你也需要 install-info 包：<br><code>$ sudo apt-get install install-info</code></p>
<p>如果你使用基于 RPM 的发行版（Fedora/RHEL/RHEL衍生版），你还需要 getopt 包 （它已经在基于 Debian 的发行版中预装了）：<br><code>sudo dnf install getopt</code></p>
<p>此外，如果你使用 Fedora/RHEL/RHEL衍生版，那么你需要执行以下命令：<br><code>$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi</code></p>
<blockquote>
<p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站 获取，网址为 <a href="https://www.kernel.org/pub/software/scm/git，" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git，</a> 或从 GitHub 网站上的镜像来获得，网址为 <a href="https://github.com/git/git/releases。" target="_blank" rel="noopener">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签 名，如果你想验证下载正确性的话会用到。 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf git-2.8.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> git-2.8.0</span><br><span class="line">make configure</span><br><span class="line">./configure --prefix=/usr </span><br><span class="line">make all doc info</span><br><span class="line">make install install-doc install-html install-info</span><br></pre></td></tr></table></figure>

<p>完成后，你可以使用 Git 来获取 Git 的更新：<br><code>git clone git://git.kernel.org/pub/scm/git/git.git</code></p>
<h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><p>获取 Git 仓库<br>通常有两种获取 Git 项目仓库的方式：</p>
<ol>
<li>将尚未进行版本控制的本地目录转换为 Git 仓库； </li>
<li>从其它服务器 克隆 一个已存在的 Git 仓库。 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。 </li>
</ol>
<p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c </span><br><span class="line">$ git add LICENSE </span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure>

<p><strong>克隆现有的仓库</strong> </p>
<p> <code>git clone &lt;url&gt;</code></p>
<p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放 入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p>
<p><strong>检查当前文件状态</strong> </p>
<p><code>git status</code></p>
<p><strong>跟踪新文件</strong> </p>
<p><code>git add</code></p>
<p><strong>忽略文件</strong> </p>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore </span><br><span class="line">*.[oa] </span><br><span class="line">*~</span><br></pre></td></tr></table></figure>

<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二 行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存 副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的 新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件</p>
<p><strong>我们再看一个 .gitignore 文件的例子：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的 .a 文件 </span></span><br><span class="line">*.a </span><br><span class="line"><span class="comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 </span></span><br><span class="line">!lib.a </span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO </span></span><br><span class="line">/TODO </span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹 </span></span><br><span class="line">build/ </span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt </span></span><br><span class="line">doc/*.txt </span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 </span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<p><strong>查看已暂存和未暂存的修改</strong> </p>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>;</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存 文件与最后一次提交的文件差异;</p>
<p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化（ –staged 和 –cached 是同义词）;</p>
<p><strong>提交更新</strong> </p>
<p><code>git commit</code></p>
<p>你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行</p>
<p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时 纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较</p>
<p><strong>跳过使用暂存区域</strong> </p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂 存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">'added new benchmarks'</span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line">1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p><strong>移除文件</strong> </p>
<p> 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。 </p>
<p><strong>查看提交历史</strong> </p>
<p><code>git log</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/100-Bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/100-Bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Bash脚本编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 13:22:33 / 修改时间：21:58:39" itemprop="dateCreated datePublished" datetime="2020-05-06T13:22:33+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="脚本文件格式"><a href="#脚本文件格式" class="headerlink" title="脚本文件格式"></a>脚本文件格式</h3><p>第一行写上<code>#!/bin/bash</code><br>注释信息 <code>#</code><br>代码注释：<br>适当的缩进和空白行；</p>
<p>语言：编程语法格式，库，算法和数据结构；<br>编程思想：<br>问题空间 –&gt; 解空间</p>
<p>Bash是典型的弱类型的编程语言<br>数据类型：字符型、整数值<br>弱类型：字符型</p>
<h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><p>局部变量<br>本地变量<br>环境变量<br>位置参数变量<br>特殊变量</p>
<h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+, -, *, /, %, **</span><br><span class="line"><span class="built_in">let</span> VAR=expression</span><br><span class="line">VAR=$[expression]</span><br><span class="line">VAR=$((expression))</span><br><span class="line">VAR=$(expr argu1 argu2 argu3)</span><br></pre></td></tr></table></figure>

<p>增强型赋值<br>变量做某种算数运算后回存到此变量中；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> i=<span class="variable">$i</span>+<span class="comment">#</span></span><br><span class="line"><span class="built_in">let</span> i+=<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><code>+=, -=, *=, /=, %=</code></p>
<h3 id="条件测试："><a href="#条件测试：" class="headerlink" title="条件测试："></a>条件测试：</h3><p>判断某需求是否满足；需要测试机制来实现；</p>
<ol>
<li>执行命令，根据命令的返回值来判断；<br>0：成功<br>1-255： 失败</li>
<li>测试表达式；<br>test expression<br>[ expression ]<br>[[ expression ]]<br>注意： expression两端必须有空白字符，否则为语法错误；</li>
</ol>
<h3 id="Bash的测试类型："><a href="#Bash的测试类型：" class="headerlink" title="Bash的测试类型："></a>Bash的测试类型：</h3><ul>
<li>数值测试</li>
<li>字符串测试</li>
<li>文字测试</li>
</ul>
<h4 id="数值测试：-数值比较；"><a href="#数值测试：-数值比较；" class="headerlink" title="数值测试： 数值比较；"></a>数值测试： 数值比较；</h4><pre><code>-eq： 是否等于；[ A -eq B ];
-ne： 是否不等于；
-gt： 是否大于；
-ge： 是否大于等于；
-lt： 是否小于；
-le： 是否小于等于；</code></pre><p>代码中的 [] 执行基本的算数运算，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] <span class="comment"># 注意等号两边不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"result 为： <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试:"></a>字符串测试:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==： 是否等于；</span><br><span class="line">&gt;： 是否大于；</span><br><span class="line">&lt;： 是否小于；</span><br><span class="line">!=：是否不等于；</span><br><span class="line">=~： 左侧字符串是否能被右侧的PATTERN匹配；</span><br><span class="line">-z <span class="string">"STRING"</span>： 判断指定的字符串是否为空；空为真，非空为假。</span><br><span class="line">-n <span class="string">"STRING"</span>： 判断指定的字符串是否非空，非空为真，空为假；</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>字符串要加引用；</li>
<li>要使用[[ ]];</li>
</ul>
<h4 id="文件测试："><a href="#文件测试：" class="headerlink" title="文件测试："></a>文件测试：</h4><ol>
<li><p>存在测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a FILE</span><br><span class="line">-e FILE: 如果文件存在则为真</span><br></pre></td></tr></table></figure>
</li>
<li><p>存在及类型测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-b 如果文件存在且为块特殊文件则为真</span><br><span class="line">-c 如果文件存在且为字符型特殊文件则为真</span><br><span class="line">-d 如果文件存在且为目录则为真</span><br><span class="line">-f 如果文件存在且为普通文件则为真</span><br><span class="line">-h 链接文件</span><br><span class="line">-p 管道文件</span><br><span class="line">-S 套接字文件</span><br><span class="line">3. 文件权限测试：</span><br><span class="line">-r 存在且可读</span><br><span class="line">-w 存在且可写</span><br><span class="line">-x 存在且可执行</span><br><span class="line">4. 特殊权限测试：</span><br><span class="line">-u 存在且拥有suid</span><br><span class="line">-g 存在且拥有sgid</span><br><span class="line">-k 存在且拥有sticky</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件内容测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s 是否有内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间戳：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-N FILE ：文件自上一次读操作后是否被修改；</span><br></pre></td></tr></table></figure>
</li>
<li><p>从属关系测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-O FILE：当前用户是否为文件的属主；</span><br><span class="line">-G FILE：当前用户是否为文件的属组；</span><br></pre></td></tr></table></figure>
</li>
<li><p>双目测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE1 -ef FILE2；FILE1与FILE2是否指向同一个文件系统的相同inode的硬链接；</span><br><span class="line">FILE1 -nt FILE2：FILE1是否新于FILE2；</span><br><span class="line">FILE1 -ot FILE2：FILE1是否旧于FILE2；</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="组合测试条件："><a href="#组合测试条件：" class="headerlink" title="组合测试条件："></a>组合测试条件：</h3><p>逻辑运算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. </span><br><span class="line">    COMMAND1 &amp;&amp; COMMAND2</span><br><span class="line">    COMMAND1 || COMMAND2</span><br><span class="line">    !COMMAND</span><br><span class="line">    [ -O FILE ] &amp;&amp; [ -r FILE ]</span><br><span class="line">2. </span><br><span class="line">    EXPRESSION1 -a EXPRESSION2</span><br><span class="line">    EXPRESSION1 -O EXPRESSION2</span><br><span class="line">    !EXPRESSION</span><br><span class="line">    [ -O FILE -a -x FILE ]</span><br></pre></td></tr></table></figure>

<p>练习：将当前主机名称保存至hostname变量中：<br>主机名如果为空，或者为localhost.localdomain,则将其设置为<a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a>;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">hostname=$(hostname)</span><br><span class="line">[ -z <span class="string">"<span class="variable">$hostname</span>"</span> -o <span class="string">"<span class="variable">$hostname</span>"</span>==<span class="string">"localhost.localdomain"</span> -o <span class="string">"<span class="variable">$hostname</span>"</span>==<span class="string">"localhost"</span> ] &amp;&amp; hostname www.magedu.com</span><br></pre></td></tr></table></figure>

<h3 id="脚本的状态返回值："><a href="#脚本的状态返回值：" class="headerlink" title="脚本的状态返回值："></a>脚本的状态返回值：</h3><p>默认是脚本执行的最后一条命令的返回值；<br>自定义状态退出状态码:<br>exit [n]：n为自己指定的状态码；<br>注意：SHELL进程遇到exit时，即会终止，因此整个脚本执行即为结束。</p>
<h3 id="向脚本传递参数"><a href="#向脚本传递参数" class="headerlink" title="向脚本传递参数"></a>向脚本传递参数</h3><h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><p>myscript.sh<br>引用方式：<br>$1,$2,$3…$10,$11…<br>轮替：<br>shift [n]: 位置参数轮替：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">file1_lines=$(grep <span class="string">"^$"</span> <span class="variable">$1</span> | wc -l)</span><br><span class="line">file2_lines=$(grep <span class="string">"^$"</span> <span class="variable">$2</span> | wc -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total blank lines: $[<span class="variable">$file1_lines</span>+<span class="variable">$file2_lines</span>]"</span></span><br></pre></td></tr></table></figure>

<h4 id="特殊变量："><a href="#特殊变量：" class="headerlink" title="特殊变量："></a>特殊变量：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span>:脚本文件路径本身;</span><br><span class="line"><span class="variable">$#</span>:脚本参数的个数；</span><br><span class="line">$*:所有参数 （分割为多个字符串）</span><br><span class="line"><span class="variable">$@</span>:所有参数 （合并为一个字符串）</span><br></pre></td></tr></table></figure>

<p><code>[ $# -lt 2 ] &amp;&amp; echo &quot;At least two files&quot; &amp;&amp; exit 1</code><br>如果参数个数小于2个，提示至少需要2个参数，并退出，状态码1</p>
<p>过程式编程语言的代码执行顺序：<br>顺序执行： 逐条执行；<br>选择执行：<br>    代码有一个分支： 条件满足时才会执行；<br>    两个或以上的分支：只会执行其中一个满足条件的分支；<br>循环执行：<br>    某代码片段（循环体）要执行0、1或者多个来回；<br>选择执行：<br>单分支的if语句：<br>if 测试条件<br>then<br>    代码分支<br>fi</p>
<p>双分支的if语句<br>if 测试条件；then<br>    条件为真时执行的分支<br>else<br>    条件为假时执行的分支<br>fi</p>
<p>示例： 通过参数传递一个用户名给脚本，此用户不存在时，则添加之；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[ <span class="variable">$#</span> -lt 1 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"At least one username."</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! grep <span class="string">"^<span class="variable">$1</span>\&gt;"</span> /etc/passwd &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    useradd <span class="variable">$1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> | passwd --stdin <span class="variable">$1</span> &amp;&gt; /dev/null</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Add user <span class="variable">$1</span> finished."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"user <span class="variable">$1</span> exist."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>练习1： 通过命令行参数给定两个数字，输出其中较大的数值；<br>练习2： 通过命令行参数指定一个用户名，判断其ID号是偶数还是奇数；<br>练习3： 通过命令行参数给定两个文本文件名，如果某文件不存在，则结束脚本执行；<br>        都存在时返回每个文件的行数，并说明其中行数较多的文件；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/1-%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/1-%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">磁盘和文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 13:22:01 / 修改时间：21:58:39" itemprop="dateCreated datePublished" datetime="2020-05-06T13:22:01+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="机械硬盘物理参数"><a href="#机械硬盘物理参数" class="headerlink" title="机械硬盘物理参数"></a>机械硬盘物理参数</h2><h3 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h3><p>硬盘按数据接口不同，大致分为<code>ATA</code>（又称<code>IDE</code>）和<code>SATA</code>以及<code>SCSI</code>和<code>SAS</code>。接口速度不是实际硬盘数据传输的速度，当前普通硬盘的实际数据传输速度一般不会超过300MB/s。</p>
<h3 id="ATA"><a href="#ATA" class="headerlink" title="ATA"></a>ATA</h3><p>全称Advanced Technology Attachment，是用传统的40-pin并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被SATA所取代。</p>
<h3 id="SATA"><a href="#SATA" class="headerlink" title="SATA"></a>SATA</h3><p>全称Serial ATA，也就是使用串口的ATA接口，特点是抗干扰性强，对数据线的要求比ATA低很多，且支持热插拔等功能。SATA-II的接口速度为300MiB/s，而新的SATA-III标准可达到600MiB/s的传输速度。SATA的数据线也比ATA的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>
<h3 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h3><p>全称Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的SCSI-II，到当前的Ultra320 SCSI以及Fiber-Channel（光纤通道），接口型式也多种多样。SCSI硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速15000rpm的高转速，且资料传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。</p>
<h3 id="SAS"><a href="#SAS" class="headerlink" title="SAS"></a>SAS</h3><p>全称Serial Attached SCSI，是新一代的SCSI技术，可兼容SATA硬盘，都是采取序列式技术以获得更高的传输速度，可达到12Gb/s。此外也透过缩小连接线改善系统内部空间等。</p>
<p>此外，由于SAS硬盘可以与SATA硬盘共享同样的背板，因此在同一个SAS存储系统中，可以用SATA硬盘来取代部分昂贵的SAS硬盘，节省整体的存储成本。但SATA存储系统并不能连接SAS硬盘。</p>
<h3 id="FC"><a href="#FC" class="headerlink" title="FC"></a>FC</h3><p>全称Fibre Channel（光纤通道接口），拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（4Gb/s或10Gb/s）、远程连接等特点；内部传输速率也比普通硬盘更高。但其价格高昂，因此FC接口通常只用于高端服务器领域。</p>
<h2 id="电源接口"><a href="#电源接口" class="headerlink" title="电源接口"></a>电源接口</h2><p>3.5寸台式机硬盘：ATA接口的硬盘一般使用D形4针电源接口（俗称“大4pin”），由Molex公司设计并持有专利；SATA硬盘则使用SATA电源线。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/ATX_PS_connectors.jpg/180px-ATX_PS_connectors.jpg" alt="alt 4p"><br>2.5寸的笔记本电脑硬盘，可直接由数据口供电，不需要额外的电源接口。在插上外接的便携式硬盘盒之后，由计算机外部的USB接口提供电力来源，而单个USB接口供电约为4~5V 500mA，若移动硬盘盒用电需求较高，有时需要接上两个USB接口才能使用，否则，需要外接电源供电。但如今多数新型硬盘盒（使用2.5寸或以下硬盘）已可方便地使用单个USB口供电。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Cylinder_Head_Sector.svg/200px-Cylinder_Head_Sector.svg.png" alt="alt"></p>
<h3 id="避免故障"><a href="#避免故障" class="headerlink" title="避免故障"></a>避免故障</h3><p>硬盘碟片转速极快，与碟片的距离极小；因此硬盘内部是无尘状态，硬盘有过滤器过滤进入硬盘的空气。为了避免磁头碰撞碟片，厂商设计出各种保护方法；当前硬盘对于地震有很好的防护力（1990年代的一些硬盘，若在使用中碰到略大的地震，就很可能损坏），防摔能力也大幅进步，电源关闭及遇到较大震动时磁头会立刻移到安全区（近期的硬盘也开始防范突然断电的情况）；而许多笔记本电脑厂商也开发出各种笔记本电脑结构来加强硬盘的防摔性。但硬盘在通电时耐摔度会降低（旋转逆动性）、也只能温和的移动，许多人也已经养成在关闭硬盘后30秒至一分钟内、不会移动硬盘（及笔记本电脑）的习惯。<br>2010年后氦气封装技术量产，以往的硬盘填充介质为空气，不过容易受到空气影响，因此碟片之间距离要够才行，而氦气的密度比起空气小上许多，且氦气特色就是稳定，使用他来当介质，阻力和震动相对小，因此碟片之间的距离就能缩小，所以同样的空间下能够装下更多的碟片，采用氦气封装的好处除了容量变大外[4]，温度和耗电能够再降低，因此耐用度和稳定性能够再提升。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>操作系统对硬盘进行读写时需要用到文件系统把硬盘的扇区组合成簇，并创建文件和树形目录制度，使操作系统对其访问和查找变得容易，这是因为操作系统直接对数目众多的扇区进行寻址会十分麻烦。</p>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>硬盘驱动器的尺寸和用途可分为：</p>
<ul>
<li>0.85英寸，多用于手机等便携设备中，已无厂商生产。</li>
<li>1英寸（微型硬盘，MicroDrive），多用于数字相机（CF type II接口），已无厂商生产。</li>
<li>1.8英寸，多用于笔记本电脑及外置硬盘盒中，已无厂商生产。</li>
<li>2.5英寸，多用于笔记本电脑及外置硬盘盒中。采用2.5”硬盘的外置硬盘盒一般不需外接电源。</li>
<li>3.5英寸，多用于台式机中。采用3.5”硬盘的外置硬盘盒一般需要外接电源，因为耗电量超过USB的供电上限，一直到USB 3.0问世后获得解决。</li>
<li>5.25英寸，多为早期台式机使用，已无厂商生产。</li>
<li>10.5英寸。</li>
<li>14英寸，NEC DKU800。<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3>当前硬盘的容量有36GB、40GB、45GB、60GB、75GB、80GB、120GB、150GB、160GB、200GB、250GB、300GB、320GB、400GB、500GB、640GB、750GB、1TB、1.5TB、2TB、2.5TB、3TB、4TB、5TB、6TB、8TB、10TB、12TB、14TB等多种规格<h3 id="转速"><a href="#转速" class="headerlink" title="转速"></a>转速</h3>硬盘每分钟旋转的圈数，单位是rpm（每分钟的转动数），有4200rpm、5400rpm、5900rpm、7200rpm、10000rpm、15000rpm、18000rpm等几种规格。一般来讲转速愈高通常数据传输速率愈好，但同时噪音、耗电量和发热量也较高。<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3>主要有2MB、8MB、16MB、32MB、64MB、128MB、256MB等规格。<h3 id="平均寻道时间"><a href="#平均寻道时间" class="headerlink" title="平均寻道时间"></a>平均寻道时间</h3>单位是ms（毫秒），有5.2ms、8.5ms、8.9ms、12ms等规格。<h3 id="内部传输速度"><a href="#内部传输速度" class="headerlink" title="内部传输速度"></a>内部传输速度</h3>包括磁头把数据从盘片读入缓存的速度，以及磁头把数据从缓存写入盘片的速度。可用来评价硬盘的读写速度和整体性能.</li>
</ul>
<p><code>一般固态硬盘的输入电压在5V左右，偏差5%以内。一般功耗较低，2.5W左右，电流500mA，这样即使usb2.0接口也能采用。</code></p>
<h3 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h3><ul>
<li>SATA: 6gbps</li>
<li>SAS: 6gbps</li>
<li>USB: 480MB/s</li>
</ul>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p>固态硬盘采用SATA、PCI Express、M.2、mSATA、SAS、U.2、ZIF、IDE、CF、CFast等接口。由于价格及存储空间与机械硬盘有巨大差距，固态硬盘无法取代机械式硬盘。<br><code>损坏时不可挽救</code></p>
<hr>
<h2 id="Linux的哲学思想：-一切皆文件"><a href="#Linux的哲学思想：-一切皆文件" class="headerlink" title="Linux的哲学思想： 一切皆文件"></a>Linux的哲学思想： 一切皆文件</h2><p>设备类型：<br>块文件（block）随机访问，数据交换单位是‘块’<br>字符（character）线性访问，数据交换单位是‘字符’<br>设备文件 FHS<br>/dev<br>    关联至设备的驱动程序：设备的访问入口<br>    设备号：<br><code>major</code>：主设备号，区分设备类型；用于表明设备所需的驱动程序<br><code>minor</code>：此设备号，区分同种类型下的不同设备，特定设备的访问入口</p>
<p><code>mknod</code> 命令:创建块类型和字符类型的特殊文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod [option]... NAME TYPE [major minor]</span><br><span class="line">    -m MODE:创建后的设备文件的访问权限。</span><br></pre></td></tr></table></figure>
<p>磁盘:分区机制<br>IDE /dev/hd[a-z]<br>SCSI,SATA,USB,SAS:/dev/sd[a-z]<br>引用设备的方式：<br>设备文件名、卷标、UUID</p>
<h3 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a><code>MBR</code></h4><p>446bytes: bootloader<br>64bytes: 分区表，每16bytes标识一个分区，一共只能有4个分区</p>
<ul>
<li>4主分区</li>
<li>3主1扩展<br>主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是电脑引导后访问硬盘时所必须要读取的首个扇区，主引导扇区记录着硬盘本身的相关消息以及硬盘各个分割的大小及位置消息，是数据消息的重要入口。如果它受到破坏，硬盘上的基本数据结构消息将会丢失，需要用繁琐的方式试探性的重建数据结构消息后才可能重新访问原先的数据，对于那些扇区为512位组的磁盘，MBR分割表不支持容量大于2.2TB（2.2×1012字节）的分割。</li>
</ul>
<h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a><code>GPT</code></h4><p>全局唯一标识分区表（GUID Partition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准（被Intel用于替代个人计算机的BIOS）的一部分。GPT分配64bits给逻辑块地址，因而使得最大分区大小在264-1个扇区成为了可能。对于每个扇区大小为512字节的磁盘，那意味着可以有9.4ZB（9.4 x 1021字节）或8 ZiB-512字节（9,444,732,965,739,290,426,880字节或 18,446,744,073,709,551,615（264-1）个扇区x 512（29）字节每扇区）。</p>
<h5 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l </span><br><span class="line">fdisk device</span><br><span class="line">    n: new</span><br><span class="line">    d: del</span><br><span class="line">    t: modify</span><br><span class="line">    w: save</span><br><span class="line">    q: without save quit</span><br><span class="line">    m: help</span><br><span class="line">    p: print</span><br></pre></td></tr></table></figure>

<p>显示内核已识别的所有分区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@testlab:~# cat &#x2F;proc&#x2F;partitions </span><br><span class="line">major minor  #blocks  name</span><br><span class="line"></span><br><span class="line">   8       16   20971520 sdb</span><br><span class="line">   8       17   20970479 sdb1</span><br><span class="line">   8        0   20971520 sda</span><br><span class="line">   8        1     748544 sda1</span><br><span class="line">   8        2          1 sda2</span><br><span class="line">   8        5   20219904 sda5</span><br><span class="line"> 252        0   19214336 dm-0</span><br><span class="line"> 252        1     999424 dm-1</span><br></pre></td></tr></table></figure>
<p> 使内核重读分区<br>centOS5: <code>partprobe [device]</code><br>centOS6,7: <code>partx -a [device]</code> (有时需要两次)<br><code>parted</code>: GNU Parted 是创建和处理分区表的程序。GParted 是 GUI 前端。<br><code>sfdisk</code>: Partition table manipulator for Linux<br><code>cfdisk</code>: Curses based disk partition table manipulator for Linux</p>
<hr>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><p>格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。格式化通常分为<code>低级格式化</code>和<code>高级格式化</code>。如果没有特别指明，对硬盘的格式化通常是指<code>高级格式化</code>，而对软盘的格式化则通常同时包括这两者。</p>
<p><code>低级格式化</code>被用于指代对磁盘进行划分柱面、磁道、扇区的操作。<br><code>高级格式化</code>又称<code>逻辑格式化</code>，它是指根据用户选定的文件系统（如FAT12、FAT16、FAT32、exFAT、NTFS、EXT2、EXT3等），在磁盘的特定区域写入特定数据，以达到初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作。高级格式化包括对主引导记录中分区表相应区域的重写、根据用户选定的文件系统，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间，以便用户使用该分区管理文件。</p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p><code>inode</code>: (index node)是指在许多“类Unix文件系统”中的一种数据结构，用于描述 文件系统对象（包括文件、目录、设备文件、socket、管道, 等等）。每个inode保存了 文件系统对象数据 的属性和磁盘块位置。文件系统对象属性 包含了各种元数据（如：最后修改时间） ，也包含用户组（owner ）和权限数据。</p>
<p>文件系统创建（格式化）时，就把存储区域分为两大连续的存储区域。一个用来保存文件系统对象的元信息数据，这是由inode组成的表，每个inode默认是256字节或者128字节。另一个用来保存“文件系统对象”的内容数据，划分为512字节的扇区，以及由8个扇区组成的4K字节的块。块是读写时的基本单位。一个文件系统的inode的总数是固定的。这限制了该文件系统所能存储的文件系统对象的总数目。典型的实现下，所有inode占用了文件系统1%左右的存储容量。</p>
<h5 id="POSIX-inode"><a href="#POSIX-inode" class="headerlink" title="POSIX inode"></a>POSIX inode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POSIX标准强制规范了文件系统的行为。每个“文件系统对象”必须具有：</span><br><span class="line"></span><br><span class="line">以字节为单位表示的文件大小。</span><br><span class="line">设备ID，标识容纳该文件的设备。</span><br><span class="line">文件所有者的User ID。</span><br><span class="line">文件的Group ID</span><br><span class="line">文件的模式（mode），确定了文件的类型，以及它的所有者、它的group、其它用户访问此文件的权限。</span><br><span class="line">额外的系统与用户标志（flag），用来保护该文件。</span><br><span class="line">3个时间戳，记录了inode自身被修改（ctime, inode change time）、文件内容被修改（mtime, modification time）、最后一次访问（atime, access time）的时间。</span><br><span class="line">1个链接数，表示有多少个硬链接指向此inode。</span><br><span class="line">到文件系统存储位置的指针。通常是1K字节或者2K字节的存储容量为基本单位。</span><br><span class="line">使用stat系统调用可以查询一个文件的inode号码及一些元信息。</span><br></pre></td></tr></table></figure>
<h3 id="Linux-的硬链接与软链接"><a href="#Linux-的硬链接与软链接" class="headerlink" title="Linux 的硬链接与软链接"></a>Linux 的硬链接与软链接</h3><p>链接简单说实际上是一种文件共享的方式，是 POSIX 中的概念，主流文件系统都支持链接文件。<br>你可以将链接简单地理解为 Windows 中常见的快捷方式（或是 OS X 中的替身），Linux 中常用它来解决一些库版本的问题，通常也会将一些目录层次较深的文件链接到一个更易访问的目录中。在这些用途上，我们通常会使用到软链接（也称符号链接）。</p>
<p>从使用的角度讲，两者没有任何区别，都与正常的文件访问方式一样，支持读写，如果是可执行文件的话也可以直接执行。</p>
<ol>
<li>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块<br><code>有相同的inode,每增加一个硬链接，会使文件inode引用计数增加</code><br><code>ln src link</code></li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。<br><code>inode 不同，删除符号连接不影响源文件，但删除原文件会使符号链接无效，建立符号链接不影响文件inode引用计数</code><br>设备文件： 存储数据指针的空间当中存储的是设备号（major，minor）；<br>bitmap index： 位图索引。<br><code>ln -s src link</code><h3 id="VFS：Virtual-File-System"><a href="#VFS：Virtual-File-System" class="headerlink" title="VFS：Virtual File System"></a>VFS：Virtual File System</h3></li>
</ol>
<ul>
<li>linux文件系统：ext2,ext3,ext4,xfs,relserfs,brfs</li>
<li>光盘：iso9660</li>
<li>网络文件系统：nfs,cifs</li>
<li>集群：gfs2,ocfs2</li>
<li>内核级分布：ceph</li>
<li>windows：vfat,ntfs</li>
<li>伪文件：proc,sysfs,tmpfs,hugepagefs</li>
<li>Unix：UFS,FFS,JFS</li>
<li>交换：SWAP</li>
<li>用户空间的分布式：mogliefs,moosefs,glusterfs</li>
</ul>
<h3 id="journal-日志文件系统"><a href="#journal-日志文件系统" class="headerlink" title="journal 日志文件系统"></a>journal 日志文件系统</h3><p>日志系统：元数据<code>metadata</code>和数据<code>data</code><br>日志文件系统（英语：Journaling file system）是一种文件系统在发生变化时，先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统的文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。</p>
<p>对文件系统进行修改时，需要进行很多操作。这些操作可能中途被打断，也就是说，这些操作不是“不可中断”(atomic)的。如果操作被打断，就可能造成文件系统出现不一致的状态。</p>
<p><code>例如：删除文件时，先要从目录树中移除文件的标示，然后收回文件占用的空间。如果在这两步之间操作被打断，文件占用的空间就无法收回。文件系统认为它是被占用的，但实际上目录树中已经找不到使用它的文件了。</code></p>
<p>在非日志文件系统中，要检查并修复类似的错误就必须对整个文件系统的数据结构进行检查。一般在挂载文件系统前，操作系统会检查它上次是否被成功卸载，如果没有，就会对其进行检查。如果文件系统很大或者I/O带宽有限，这个操作可能会花费很长时间。<br>为了避免这样的问题，日志文件系统分配了一个称为日志（journal）的区域来提前记录要对文件系统做的更改。在崩溃后，只要读取日志重新执行未完成的操作，文件系统就可以恢复一致。这种恢复是原子的，因为只存在几种情况：</p>
<ul>
<li>不需要重新执行：这个事务被标记为已经完成</li>
<li>成功重新执行：根据日志，这个事务被重新执行</li>
<li>无法重新执行：这个事务会被撤销，就如同这个事务从来没有发生过</li>
<li>日志本身不完整：事务还没有被完全写入日志，它会被简单忽略<h4 id="日志的三个级别"><a href="#日志的三个级别" class="headerlink" title="日志的三个级别"></a>日志的三个级别</h4></li>
<li>回写<br><code>在回写模式中，只有元数据被记录到日志中，数据会被直接写入主文件系统。这种模式能提供较好的性能，不过有较大的风险。例如：在增大文件时，数据还未写入就发生崩溃，那么文件系统恢复后，文件后面就可能出现垃圾数据。</code></li>
<li>顺序<br><code>在顺序模式中，只有元数据被记录到日志中，但在日志被标记为提交前，数据会被写入文件系统。在这种模式下，如果在增大文件时，数据还未写入就发生崩溃，那么在恢复时这个事务会被简单的撤销，文件保持原来的状态。</code></li>
<li>数据  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 日志完整：这时事务会被重新执行，修改会被提交到主文件系统</span><br><span class="line">- 日志不完整：这时主文件系统还未被修改，只需要简单放弃这个事务</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>常见的日志文件系统</p>
<ul>
<li>JFS：IBM的 Journaled File System, 最早的日志文件系统[1]。</li>
<li>Ext4/Ext3文件系统：由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。</li>
<li>XFS文件系统：广泛用于Linux系统，取代了Ext4。</li>
<li>ReiserFS：用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。</li>
<li>Btrfs：用B树作为数据结构，被认为是下一代Linux文件系统[2]。</li>
<li>NTFS：微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。</li>
<li>HFS+：苹果公司发展的OS X操作系统下主要使用的文件系统。</li>
</ul>
<h3 id="文件系统管理工具"><a href="#文件系统管理工具" class="headerlink" title="文件系统管理工具"></a>文件系统管理工具</h3><ul>
<li>创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkfs -v -t fs-type device</span><br><span class="line">ext系列专用 mke2fs</span><br><span class="line">    -t &#123;ext2、ext3、ext4&#125;： 指明文件系统类型</span><br><span class="line">    -b &#123;1024 | 2048 | 4096&#125;： 指明文件系统的块大小</span><br><span class="line">    -L LABEL： 指明卷标</span><br><span class="line">    -j： 创建有日志功能的文件系统ext3；</span><br><span class="line">        mke2fs -j &#x3D; mke2fs -t ext3 &#x3D; mkfs.ext3</span><br><span class="line">    -i 每多少字节创建inode</span><br><span class="line">    -N 直接指明要给此文件系统创建inode的数量；</span><br><span class="line">    -O [^]FEATURE: 以指定的特性创建目标文件系统，不加拖字符表示启用，加拖字符表示关闭特性；</span><br><span class="line">    -m 指定为超级用户保留的文件系统块的百分比。这样可以避免碎片，并允许root拥有的守护程序，默认为5%。</span><br></pre></td></tr></table></figure></li>
<li>检测和修复<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fsck: 用于实现文件系统检测的工具；</span><br><span class="line">因进程意外中止或者系统崩溃等原因导致定稿操作非正常终止时，可能会造成文件损坏；</span><br><span class="line">此时，应该检测并修复文件系统；建议，离线进行（非挂载状态）；</span><br><span class="line"></span><br><span class="line">e2fsck: 检测ext2&#x2F;3&#x2F;4 文件系统错误</span><br><span class="line">e2fsck [option] device</span><br><span class="line">    -y: 默认对所有问题自动回答yes；</span><br><span class="line">    -f：及时文件系统处于clean状态，也check一遍；</span><br><span class="line"></span><br><span class="line">fsck: check and repair a Linux filesystem</span><br><span class="line">    -t: fslist 指定文件系统类型；</span><br><span class="line">    -a: 自动修复文件系统，不询问任何问题（请谨慎使用此选项）。</span><br><span class="line">    -r: 交互式修复；</span><br></pre></td></tr></table></figure></li>
<li>查看属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs ：显示ext系列文件系统的属性信息；</span><br><span class="line">    dumpe2fs [-h] device</span><br><span class="line">tune2fs:</span><br><span class="line">    查看或者修改ext系列文件系统的某些属性。</span><br><span class="line">    tune2fs [option] device</span><br><span class="line">        -l 查看超级块信息</span><br><span class="line">    修改：</span><br><span class="line">        -j ext2升级为ext3，无损升级，有数据也可升级;</span><br><span class="line">        -L LABEL: 修改卷标</span><br><span class="line">        -m 修改预留块的百分比；</span><br><span class="line">        -O [^] 开启或者关闭某种特性；</span><br><span class="line">        -o [^]mount_options：开启或者关闭某种默认挂载选项；</span><br><span class="line">            acl&#x2F;^acl: 开启或者关闭acl</span><br><span class="line">blkid: 查找&#x2F;打印块设备属性</span><br><span class="line">    -L: 查找使用此文件系统标签的设备；</span><br><span class="line">    -k: 列出所有已知的文件系统&#x2F; RAID并退出;</span><br></pre></td></tr></table></figure></li>
<li>调整文件系统特性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e2label - 更改ext2 &#x2F; ext3 &#x2F; ext4文件系统上的卷标</span><br><span class="line">    查看：e2label device</span><br><span class="line">    设定：e2label device LABEL</span><br></pre></td></tr></table></figure>
CentOS6 如何使用xfs文件系统：<br>联网的话：<code>yum install xfsprogs</code></li>
</ul>
<h4 id="Swap-文件系统"><a href="#Swap-文件系统" class="headerlink" title="Swap 文件系统"></a>Swap 文件系统</h4><p>linux 的交换分区必须使用独立的文件系统<br>且文件系统的system ID必须为82；<br>创建Swap设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkswap [option] device</span><br><span class="line">    -L LABEL: 指明卷标</span><br><span class="line">    -f： 强制</span><br></pre></td></tr></table></figure>
<p>windows无法识别Linux的文件系统；因此，存储设备需要在两=两种系统之间交叉使用时，应该使用fat32（vfat）；<br><code>mkfs.vfat device</code></p>
<p>练习1:</p>
<p>练习2:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/102-Git-%E5%92%8C-GitHub-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/102-Git-%E5%92%8C-GitHub-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Git 和 GitHub 使用入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 07:03:09 / 修改时间：23:16:55" itemprop="dateCreated datePublished" datetime="2020-05-06T07:03:09+08:00">2020-05-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用常见-Git-命令"><a href="#使用常见-Git-命令" class="headerlink" title="使用常见 Git 命令"></a>使用常见 Git 命令</h1><h2 id="推送提交到远程仓库"><a href="#推送提交到远程仓库" class="headerlink" title="推送提交到远程仓库"></a>推送提交到远程仓库</h2><p>使用 <code>git push</code> 将本地分支上的提交推送到远程仓库。<br>git push 命令使用两个参数：</p>
<ul>
<li>远程命令，如 <code>origin</code></li>
<li>分支名称，如 <code>master</code><br>例如：<br><code>git push  &lt;REMOTENAME&gt; &lt;BRANCHNAME&gt;</code><br>例如，您通常运行 git push origin master 来推送本地更改到在线仓库。</li>
</ul>
<p><strong>重命名分支</strong><br>要重命名分支，同样使用 git push 命令，但要加上一个或多个参数：新分支的名称。<br> 例如：<br><code>git push  &lt;REMOTENAME&gt; &lt;LOCALBRANCHNAME&gt;:&lt;REMOTEBRANCHNAME&gt;</code><br>这会将 <code>LOCALBRANCHNAME</code> 推送到 <code>REMOTENAME</code>，但其名称将改为 <code>REMOTEBRANCHNAME</code>。<br>如果仓库的本地副本未同步或“落后于”您推送到的上游分支，您会收到一条消息表示：non-fast-forward updates were rejected。 这意味着您必须检索或“提取”上游更改，然后才可推送本地更改。</p>
<p><strong>推送标记</strong><br>默认情况下，没有其他参数时，git push 会发送所有名称与远程分支相同的匹配分支。<br>要推送单一标记，可以发出与推送分支相同的命令：<br><code>git push  &lt;REMOTENAME&gt; &lt;TAGNAME&gt;</code><br>要推送所有标记，可以输入命令：<br><code>git push  &lt;REMOTENAME&gt; --tags</code></p>
<p><strong>删除远程分支或标记</strong><br>删除分支的语法初看有点神秘：<br><code>git push  &lt;REMOTENAME&gt; :&lt;BRANCHNAME&gt;</code></p>
<p><strong>远程和复刻</strong><br>在克隆您拥有的仓库时，向其提供远程 URL，告知 Git 到何处提取和推送更新。 如果要协作处理原始仓库，可添加新的远程 URL（通常称为 upstream）到本地 Git 克隆：<br><code>git remote add upstream  &lt;THEIR_REMOTE_URL&gt;</code></p>
<h2 id="从远程仓库获取更改"><a href="#从远程仓库获取更改" class="headerlink" title="从远程仓库获取更改"></a>从远程仓库获取更改</h2><p>您可以使用常用 Git 命令访问远程仓库。<br>与远程仓库交互时，这些命令非常有用。 <code>clone</code> 和 <code>fetch</code> 用于从仓库的远程 URL 将远程代码下载到您的本地计算机，<code>merge</code> 用于将其他人的工作与您的工作合并在一起，而 <code>pull</code> 是 <code>fetch</code> 和 <code>merge</code> 的组合。</p>
<p><strong>克隆仓库</strong><br>要获取其他用户仓库的完整副本，请使用 <code>git clone</code>，如下所示：<br><code>git clone https://github.com/USERNAME/REPOSITORY.git</code><br><code>将仓库克隆到您的计算机</code><br>运行 git clone 时，将发生以下操作：</p>
<ul>
<li>创建名为 <code>repo</code> 的文件夹</li>
<li>将它初始化为 Git 仓库</li>
<li>创建名为 <code>origin</code> 的远程仓库，指向用于克隆的 URL</li>
<li>将所有的仓库文件和提交下载到那里</li>
<li>检出默认分支（通常称为<code>master</code>）<br>对于远程仓库中的每个 foo 分支，在本地仓库中创建相应的远程跟踪分支 <code>refs/remotes/origin/foo</code>。 通常可以将此类远程跟踪分支名称缩写为<code>origin/foo</code>。</li>
</ul>
<p><strong>从远程仓库获取更改</strong><br>使用 <code>git fetch</code> 可检索其他人完成的新工作。 从仓库获取将会获取所有新的远程跟踪分支和标记，但不会将这些更改合并到您自己的分支中。<br>如果已经有一个本地仓库包含为所需项目设置的远程 URL，您可以在终端使用 <code>git fetch *remotename*</code> 获取所有新信息：<br><code>git fetch remotename</code><br><code>获取远程仓库的更新</code></p>
<p><strong>合并更改到本地分支</strong><br>合并可将您的本地更改与其他人所做的更改组合起来。</p>
<p>通常将远程跟踪分支（即从远程仓库获取的分支）与您的本地分支进行合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge remotename&#x2F;branchname</span><br><span class="line">将在线更新与您的本地工作进行合并</span><br></pre></td></tr></table></figure>

<p><strong>从远程仓库拉取更改</strong><br><code>git pull</code> 是在同一个命令中完成 <code>git fetch</code> 和 <code>git merge</code> 的便捷方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull remotename branchname</span><br><span class="line">获取在线更新并将其与您的本地工作进行合并</span><br></pre></td></tr></table></figure>
<h2 id="管理远程仓库"><a href="#管理远程仓库" class="headerlink" title="管理远程仓库"></a>管理远程仓库</h2><p> 添加远程<br><code>git remote add</code> 命令使用两个参数：</p>
<ul>
<li>远程命令，如 <code>origin</code></li>
<li>远程 URL，如 <code>https://github.com/user/repo.git</code></li>
</ul>
<p><strong>重命名远程</strong><br><code>git remote rename</code> 命令使用两个参数：</p>
<ul>
<li>现有的远程名称，例如 <code>origin</code></li>
<li>远程的新名称，例如 <code>destination</code></li>
</ul>
<p><strong>删除远程</strong><br><code>git remote rm</code> 命令使用一个参数：<br>远程名称，例如 <code>destination</code></p>
<p><a href="https://help.github.com/cn/github/using-git/splitting-a-subfolder-out-into-a-new-repository" target="_blank" rel="noopener">将子文件夹拆分成新仓库</a></p>
<h2 id="在-Git-中设置用户名"><a href="#在-Git-中设置用户名" class="headerlink" title="在 Git 中设置用户名"></a>在 Git 中设置用户名</h2><ul>
<li>全局设置：<br>  <code>git config --global user.name &quot;Mona Lisa&quot;</code></li>
<li>为一个仓库设置 Git 用户名<br>  <code>git config user.name &quot;Mona Lisa&quot;</code></li>
<li>在 Git 中设置您的提交电子邮件地址<br>  <code>git config --global user.email &quot;email@example.com&quot;</code></li>
</ul>
<p><strong>在 Git 中缓存 GitHub 密码</strong><br>如果使用 HTTPS 克隆 GitHub 仓库</p>
<ul>
<li>windows: <code>git config --global credential.helper wincred</code></li>
<li>linux: <code>git config --global credential.helper cache</code></li>
<li>更改默认的密码缓存时限: <code>git config --global credential.helper &#39;cache --timeout=3600&#39;</code>(以秒为单位)</li>
</ul>
<p><strong>为什么 Git 总是询问我的密码？</strong><br>如果 Git 在您每次尝试与 GitHub 交互时均提示输入用户名和密码，则您可能为仓库使用的是 HTTPS 克隆 URL。</p>
<h2 id="新增-SSH-密钥到-GitHub-帐户"><a href="#新增-SSH-密钥到-GitHub-帐户" class="headerlink" title="新增 SSH 密钥到 GitHub 帐户"></a>新增 SSH 密钥到 GitHub 帐户</h2><ol>
<li>将 SSH 密钥复制到剪贴板</li>
</ol>
<ul>
<li><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></li>
<li><code>Copy</code> your <code>.ssh/id_rsa.pub</code></li>
</ul>
<ol start="2">
<li><p>在任何页面的右上角，单击您的个人资料照片，然后单击 Settings（设置）。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/userbar-account-settings.png" width="20%">
</li>
<li><p>在用户设置侧边栏中，单击 SSH and GPG keys（SSH 和 GPG 密钥）。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/settings-sidebar-ssh-keys.png" width="30%">
</li>
<li><p>单击 New SSH key（新 SSH 密钥）或 Add SSH key（添加 SSH 密钥）。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/ssh-add-ssh-key.png" width="50%">
</li>
<li><p>在 “Title”（标题）字段中，为新密钥添加描述性标签。 例如，如果您使用的是个人 Mac，此密钥名称可能是 “Personal MacBook Air”。</p>
</li>
<li><p>将密钥粘贴到 “Key”（密钥）字段。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/ssh-key-paste.png" width="50%">
</li>
<li><p>单击 Add SSH key（添加 SSH 密钥）。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/ssh-add-key.png" width="10%">
</li>
<li><p>如有提示，请确认您的 GitHub Enterprise 密码。</p>
<img src="https://github-images.s3.amazonaws.com/enterprise/2.20/assets/images/help/settings/sudo_mode_popup.png" width="20%">

</li>
</ol>
<p><em>参考：</em><a href="https://help.github.com/cn/enterprise/2.20/user/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">使用 SSH 连接到 GitHub</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/103-Text-to-AscII-Art/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/103-Text-to-AscII-Art/" class="post-title-link" itemprop="url">Text to AscII Art</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 07:02:19 / 修改时间：23:16:55" itemprop="dateCreated datePublished" datetime="2020-05-06T07:02:19+08:00">2020-05-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Figlet"><a href="#Figlet" class="headerlink" title="Figlet"></a>Figlet</h1><h1 id="Toilet"><a href="#Toilet" class="headerlink" title="Toilet"></a>Toilet</h1><h2 id="figlet"><a href="#figlet" class="headerlink" title="figlet"></a>figlet</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: figlet [ -cklnoprstvxDELNRSWX ] [ -d fontdirectory ]</span><br><span class="line">              [ -f fontfile ] [ -m smushmode ] [ -w outputwidth ]</span><br><span class="line">              [ -C controlfile ] [ -I infocode ] [ message ]</span><br></pre></td></tr></table></figure>

<h2 id="toilet"><a href="#toilet" class="headerlink" title="toilet"></a>toilet</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-f, --font &lt;name&gt;        select the font</span><br><span class="line">  -d, --directory &lt;dir&gt;    specify font directory</span><br><span class="line">  -s, -S, -k, -W, -o       render mode (default, force smushing,</span><br><span class="line">                           kerning, full width, overlap)</span><br><span class="line">  -w, --width &lt;width&gt;      <span class="built_in">set</span> output width</span><br><span class="line">  -t, --termwidth          adapt to terminal<span class="string">'s width</span></span><br><span class="line"><span class="string">  -F, --filter &lt;filters&gt;   apply one or several filters to the text</span></span><br><span class="line"><span class="string">  -F, --filter list        list available filters</span></span><br><span class="line"><span class="string">      --gay                rainbow filter (same as -F gay)</span></span><br><span class="line"><span class="string">      --metal              metal filter (same as -F metal)</span></span><br><span class="line"><span class="string">  -E, --export &lt;format&gt;    select export format</span></span><br><span class="line"><span class="string">  -E, --export list        list available export formats</span></span><br><span class="line"><span class="string">      --irc                output IRC colour codes (same as -E irc)</span></span><br><span class="line"><span class="string">      --html               output an HTML document (same as -E html)</span></span><br><span class="line"><span class="string">  -h, --help               display this help and exit</span></span><br><span class="line"><span class="string">  -I, --infocode &lt;code&gt;    print FIGlet-compatible infocode</span></span><br><span class="line"><span class="string">  -v, --version            output version information and exit</span></span><br><span class="line"><span class="string">Usage: toilet [ -hkostvSW ] [ -d fontdirectory ]</span></span><br><span class="line"><span class="string">              [ -f fontfile ] [ -F filter ] [ -w outputwidth ]</span></span><br><span class="line"><span class="string">              [ -I infocode ] [ -E format ] [ message ]</span></span><br></pre></td></tr></table></figure>

<h2 id="生成艺术字"><a href="#生成艺术字" class="headerlink" title="生成艺术字"></a>生成艺术字</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@testlab:/usr/share/figlet/fonts<span class="meta"># figlet -f Graffiti.flf jack</span></span><br><span class="line">     __               __    </span><br><span class="line">    |__|____    ____ |  | __</span><br><span class="line">    |  \__  \ _/ ___\|  |/ /</span><br><span class="line">    |  |/ __ \\  \___|    &lt; </span><br><span class="line">/\__|  (____  /\___  &gt;__|_ \</span><br><span class="line">\______|    \/     \/     \/</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@testlab:~<span class="meta"># figlet -f /usr/share/figlet/fonts/Graffiti.flf <span class="meta-string">"A man from Mars!"</span> -t</span></span><br><span class="line">   _____                              _____                           _____                      ._.</span><br><span class="line">  /  _  \     _____ _____    ____   _/ ____\______  ____   _____     /     \ _____ _______  _____| |</span><br><span class="line"> /  /_\  \   /     \\__  \  /    \  \   __\\_  __ \/  _ \ /     \   /  \ /  \\__  \\_  __ \/  ___/ |</span><br><span class="line">/    |    \ |  Y Y  \/ __ \|   |  \  |  |   |  | \(  &lt;_&gt; )  Y Y  \ /    Y    \/ __ \|  | \/\___ \ \|</span><br><span class="line">\____|__  / |__|_|  (____  /___|  /  |__|   |__|   \____/|__|_|  / \____|__  (____  /__|  /____  &gt;__</span><br><span class="line">        \/        \/     \/     \/                             \/          \/     \/           \/ \/</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lcxiao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcxiao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%82%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">文件系统的挂载和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-06 06:59:43 / 修改时间：23:16:55" itemprop="dateCreated datePublished" datetime="2020-05-06T06:59:43+08:00">2020-05-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统的使用-挂载和卸载"><a href="#文件系统的使用-挂载和卸载" class="headerlink" title="文件系统的使用 挂载和卸载"></a>文件系统的使用 挂载和卸载</h2><p><code>mount</code> 和 <code>umount</code><br>根文件系统以为的文件系统要想能够被访问,必须通过 “关联” 至根文件系统的某个目录上，此关联即为 “挂载” ；此目录即为 “挂载点” ；<br>mount_point：用于作为另一个文件系统的访问入口；</p>
<ol>
<li>事先存在</li>
<li>应该使用未被或者不会被其他进程使用到的目录；</li>
<li>挂载点下原有的文件会被隐藏；（最好是使用原来是空的目录）；<h3 id="mount命令："><a href="#mount命令：" class="headerlink" title="mount命令："></a>mount命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mount [-fnrsvw] [-t vfstype] [-o options] device dir</span><br><span class="line">    -r： readonly，只读挂载（比如光盘）；</span><br><span class="line">    -w: read and write 读写挂载；</span><br><span class="line">    -n： 默认情况下，设备挂载或者卸载的操作会同步更新至&#x2F;etc&#x2F;mtab文件中，-n用于禁止此特性；</span><br><span class="line">    -t vfstype：指明要挂载的设备上的文件系统的类型，多数情况下可自动识别，mount会通过blkid来判断要挂载的设备的文件系统类型；</span><br><span class="line">    -L LABEL： 挂载是以卷标的方式指明设备；</span><br><span class="line">    -U UUID DIR: 通过UUID挂载设备；</span><br><span class="line">    -o: 挂载选项；</span><br><span class="line">        sync&#x2F;async: 同步&#x2F;异步操作；（异步是先写入内存，随后写入磁盘，性能好，但安全行肯定没有同步安全）</span><br><span class="line">        atime&#x2F;noatime: 每个文件或目录被访问时是否立即更新其访问时间戳；</span><br><span class="line">        diratime&#x2F;nodiratime: 每个目录被访问时是否立即更新其访问时间戳；</span><br><span class="line">        remount: 重新挂载</span><br><span class="line">        acl: 支持使用acl功能；</span><br><span class="line">        mount -o acl DEVICE DIR</span><br><span class="line">        tune2fs -o acl device</span><br><span class="line">        ro： 只读</span><br><span class="line">        rw： 读写</span><br><span class="line">        dev&#x2F;nodev： 此设备上是否允许创建设备文件；</span><br><span class="line">        exec&#x2F;noexec： 是否允许运行此设备上的文件；</span><br><span class="line">        auto&#x2F;noauto： 是否允许自动运行；</span><br><span class="line">        user&#x2F;nouser： 是否允许普通用户挂载此文件系统；</span><br><span class="line">        suid&#x2F;nosuid： 是否允许程序文件上的suid和sgid特殊权限生效；</span><br><span class="line">        defaults： 使用默认选项：rw，suid，dev，exec，auto，nouser和async。</span><br><span class="line">            请注意，所有默认安装选项的实际设置取决于内核和文件系统类型。</span><br><span class="line">技巧：可以实现将目录绑定至另一个目录上，作为其临时访问入口</span><br><span class="line">mount --bind 源目录 目标目录</span><br></pre></td></tr></table></figure>
mount -r /dev/cdrom mount_point<h5 id="光盘设备一般为："><a href="#光盘设备一般为：" class="headerlink" title="光盘设备一般为："></a>光盘设备一般为：</h5> /dev/cdrom<br> /dev/dvd<br> /dev/sr0<h5 id="挂载U盘："><a href="#挂载U盘：" class="headerlink" title="挂载U盘："></a>挂载U盘：</h5> 事先识别U盘的设备文件：<h5 id="挂载本地回环设备；"><a href="#挂载本地回环设备；" class="headerlink" title="挂载本地回环设备；"></a>挂载本地回环设备；</h5> mount -o loop /PATH/TO?SOME_LOOP_FILE MOUNT_POINT<br> 例如ISO镜像文件<h4 id="查看当前已挂载的设备"><a href="#查看当前已挂载的设备" class="headerlink" title="查看当前已挂载的设备:"></a>查看当前已挂载的设备:</h4> mount<br> cat /proc/mounts<br> cat /etc/mtab</li>
</ol>
<h3 id="查看挂载设备被哪些进程所占用"><a href="#查看挂载设备被哪些进程所占用" class="headerlink" title="查看挂载设备被哪些进程所占用"></a>查看挂载设备被哪些进程所占用</h3><pre><code>fuser -v MOUNT_POINT
lsof MOUNT_POINT</code></pre><h3 id="终止所有正在访问某挂载点的进程："><a href="#终止所有正在访问某挂载点的进程：" class="headerlink" title="终止所有正在访问某挂载点的进程："></a>终止所有正在访问某挂载点的进程：</h3><pre><code>fuser -km MOUNT_POINT</code></pre><h3 id="umount命令："><a href="#umount命令：" class="headerlink" title="umount命令："></a>umount命令：</h3><pre><code>umount device | dir</code></pre><p>注意：正在被进程访问到的挂载点无法被卸载：</p>
<h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><pre><code>mkswap
启用：swapon
    -a 所有swap文件；(定义在fstab文件中的swap设备)；
禁用：swapoff
    swapoff DEVICE</code></pre><h3 id="设定除根文件系统以外的其他文件系统能够开机时自动挂载：-etc-fstab文件"><a href="#设定除根文件系统以外的其他文件系统能够开机时自动挂载：-etc-fstab文件" class="headerlink" title="设定除根文件系统以外的其他文件系统能够开机时自动挂载： /etc/fstab文件"></a>设定除根文件系统以外的其他文件系统能够开机时自动挂载： /etc/fstab文件</h3><table>
<thead>
<tr>
<th>要挂载的设备</th>
<th>挂载点</th>
<th>文件系统类型</th>
<th>挂载选项</th>
<th>转储频率（备份）</th>
<th>自检次序</th>
</tr>
</thead>
<tbody><tr>
<td>设备文件</td>
<td>swap为swap</td>
<td></td>
<td>defaults</td>
<td>0从不</td>
<td>0不自检</td>
</tr>
<tr>
<td>LABEL</td>
<td></td>
<td></td>
<td>acl</td>
<td>1每天</td>
<td>1，首先自检，通常根是1</td>
</tr>
<tr>
<td>UUID</td>
<td></td>
<td></td>
<td>noatime</td>
<td>2隔天</td>
<td>2 次级自检</td>
</tr>
<tr>
<td>伪文件系统proc，sysfs，tmpfs</td>
<td></td>
<td></td>
<td>noexec</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>mount -a： 可自动挂载定义在此文件中的所有支持的自动挂载的设备</p>
<h3 id="两个命令："><a href="#两个命令：" class="headerlink" title="两个命令："></a>两个命令：</h3><pre><code>du：估计文件空间使用率;
    -h: 以人类可读的格式打印尺寸（例如1K 234M 2G）
    -s: 对于目录，不包括子目录的大小;
df：报告文件系统磁盘空间使用情况;
    -l: 将列表限制为本地文件系统;
    -h: 以1024的幂为单位的打印尺寸（例如1023M）
    -i: 列出索引节点信息而不是块使用情况;
    -a: 包括伪，重复，不可访问的文件系统;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lcxiao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://163.com/" title="http:&#x2F;&#x2F;163.com" rel="noopener" target="_blank">163</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://baidu.com/" title="http:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">baidu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="/dalipan.com" title="dalipan.com">dalipan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lcxiao</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
